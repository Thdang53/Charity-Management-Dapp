{"ast":null,"code":"import _objectSpread from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { toBase58 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { ArgumentSchema, TransactionDataSchema } from \"./data/internal.js\";\nimport { transactionDataFromV1 } from \"./data/v1.js\";\nimport { hashTypedData } from \"./hash.js\";\nimport { getIdFromCallArg, remapCommandArguments } from \"./utils.js\";\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nclass TransactionDataBuilder {\n  constructor(clone) {\n    var _clone$sender, _clone$expiration, _clone$inputs, _clone$commands, _clone$gasData;\n    this.version = 2;\n    this.sender = (_clone$sender = clone === null || clone === void 0 ? void 0 : clone.sender) !== null && _clone$sender !== void 0 ? _clone$sender : null;\n    this.expiration = (_clone$expiration = clone === null || clone === void 0 ? void 0 : clone.expiration) !== null && _clone$expiration !== void 0 ? _clone$expiration : null;\n    this.inputs = (_clone$inputs = clone === null || clone === void 0 ? void 0 : clone.inputs) !== null && _clone$inputs !== void 0 ? _clone$inputs : [];\n    this.commands = (_clone$commands = clone === null || clone === void 0 ? void 0 : clone.commands) !== null && _clone$commands !== void 0 ? _clone$commands : [];\n    this.gasData = (_clone$gasData = clone === null || clone === void 0 ? void 0 : clone.gasData) !== null && _clone$gasData !== void 0 ? _clone$gasData : {\n      budget: null,\n      price: null,\n      owner: null,\n      payment: null\n    };\n  }\n  static fromKindBytes(bytes) {\n    const kind = bcs.TransactionKind.parse(bytes);\n    const programmableTx = kind.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: null,\n      expiration: null,\n      gasData: {\n        budget: null,\n        owner: null,\n        payment: null,\n        price: null\n      },\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static fromBytes(bytes) {\n    const rawData = bcs.TransactionData.parse(bytes);\n    const data = rawData === null || rawData === void 0 ? void 0 : rawData.V1;\n    const programmableTx = data.kind.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasData: data.gasData,\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static restore(data) {\n    if (data.version === 2) {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, data));\n    } else {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n    }\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toBase58(hash);\n  }\n  // @deprecated use gasData instead\n  get gasConfig() {\n    return this.gasData;\n  }\n  // @deprecated use gasData instead\n  set gasConfig(value) {\n    this.gasData = value;\n  }\n  build() {\n    var _overrides$expiration, _overrides$sender, _this$gasData$owner;\n    let {\n      maxSizeBytes = Infinity,\n      overrides,\n      onlyTransactionKind\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const inputs = this.inputs;\n    const commands = this.commands;\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        commands\n      }\n    };\n    if (onlyTransactionKind) {\n      return bcs.TransactionKind.serialize(kind, {\n        maxSize: maxSizeBytes\n      }).toBytes();\n    }\n    const expiration = (_overrides$expiration = overrides === null || overrides === void 0 ? void 0 : overrides.expiration) !== null && _overrides$expiration !== void 0 ? _overrides$expiration : this.expiration;\n    const sender = (_overrides$sender = overrides === null || overrides === void 0 ? void 0 : overrides.sender) !== null && _overrides$sender !== void 0 ? _overrides$sender : this.sender;\n    const gasData = _objectSpread(_objectSpread(_objectSpread({}, this.gasData), overrides === null || overrides === void 0 ? void 0 : overrides.gasConfig), overrides === null || overrides === void 0 ? void 0 : overrides.gasData);\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasData.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasData.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasData.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : {\n        None: true\n      },\n      gasData: {\n        payment: gasData.payment,\n        owner: prepareSuiAddress((_this$gasData$owner = this.gasData.owner) !== null && _this$gasData$owner !== void 0 ? _this$gasData$owner : sender),\n        price: BigInt(gasData.price),\n        budget: BigInt(gasData.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          commands\n        }\n      }\n    };\n    return bcs.TransactionData.serialize({\n      V1: transactionData\n    }, {\n      maxSize: maxSizeBytes\n    }).toBytes();\n  }\n  addInput(type, arg) {\n    const index = this.inputs.length;\n    this.inputs.push(arg);\n    return {\n      Input: index,\n      type,\n      $kind: \"Input\"\n    };\n  }\n  getInputUses(index, fn) {\n    this.mapArguments((arg, command) => {\n      if (arg.$kind === \"Input\" && arg.Input === index) {\n        fn(arg, command);\n      }\n      return arg;\n    });\n  }\n  mapCommandArguments(index, fn) {\n    const command = this.commands[index];\n    switch (command.$kind) {\n      case \"MoveCall\":\n        command.MoveCall.arguments = command.MoveCall.arguments.map(arg => fn(arg, command, index));\n        break;\n      case \"TransferObjects\":\n        command.TransferObjects.objects = command.TransferObjects.objects.map(arg => fn(arg, command, index));\n        command.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n        break;\n      case \"SplitCoins\":\n        command.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n        command.SplitCoins.amounts = command.SplitCoins.amounts.map(arg => fn(arg, command, index));\n        break;\n      case \"MergeCoins\":\n        command.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n        command.MergeCoins.sources = command.MergeCoins.sources.map(arg => fn(arg, command, index));\n        break;\n      case \"MakeMoveVec\":\n        command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(arg => fn(arg, command, index));\n        break;\n      case \"Upgrade\":\n        command.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n        break;\n      case \"$Intent\":\n        const inputs = command.$Intent.inputs;\n        command.$Intent.inputs = {};\n        for (const [key, value] of Object.entries(inputs)) {\n          command.$Intent.inputs[key] = Array.isArray(value) ? value.map(arg => fn(arg, command, index)) : fn(value, command, index);\n        }\n        break;\n      case \"Publish\":\n        break;\n      default:\n        throw new Error(\"Unexpected transaction kind: \".concat(command.$kind));\n    }\n  }\n  mapArguments(fn) {\n    for (const commandIndex of this.commands.keys()) {\n      this.mapCommandArguments(commandIndex, fn);\n    }\n  }\n  replaceCommand(index, replacement) {\n    let resultIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : index;\n    if (!Array.isArray(replacement)) {\n      this.commands[index] = replacement;\n      return;\n    }\n    const sizeDiff = replacement.length - 1;\n    this.commands.splice(index, 1, ...structuredClone(replacement));\n    this.mapArguments((arg, _command, commandIndex) => {\n      if (commandIndex < index + replacement.length) {\n        return arg;\n      }\n      if (typeof resultIndex !== \"number\") {\n        if (arg.$kind === \"Result\" && arg.Result === index || arg.$kind === \"NestedResult\" && arg.NestedResult[0] === index) {\n          if (!(\"NestedResult\" in arg) || arg.NestedResult[1] === 0) {\n            return parse(ArgumentSchema, structuredClone(resultIndex));\n          } else {\n            throw new Error(\"Cannot replace command \".concat(index, \" with a specific result type: NestedResult[\").concat(index, \", \").concat(arg.NestedResult[1], \"] references a nested element that cannot be mapped to the replacement result\"));\n          }\n        }\n      }\n      switch (arg.$kind) {\n        case \"Result\":\n          if (arg.Result === index && typeof resultIndex === \"number\") {\n            arg.Result = resultIndex;\n          }\n          if (arg.Result > index) {\n            arg.Result += sizeDiff;\n          }\n          break;\n        case \"NestedResult\":\n          if (arg.NestedResult[0] === index && typeof resultIndex === \"number\") {\n            return {\n              $kind: \"NestedResult\",\n              NestedResult: [resultIndex, arg.NestedResult[1]]\n            };\n          }\n          if (arg.NestedResult[0] > index) {\n            arg.NestedResult[0] += sizeDiff;\n          }\n          break;\n      }\n      return arg;\n    });\n  }\n  replaceCommandWithTransaction(index, otherTransaction, result) {\n    if (result.$kind !== \"Result\" && result.$kind !== \"NestedResult\") {\n      throw new Error(\"Result must be of kind Result or NestedResult\");\n    }\n    this.insertTransaction(index, otherTransaction);\n    this.replaceCommand(index + otherTransaction.commands.length, [], \"Result\" in result ? {\n      NestedResult: [result.Result + index, 0]\n    } : {\n      NestedResult: [result.NestedResult[0] + index, result.NestedResult[1]]\n    });\n  }\n  insertTransaction(atCommandIndex, otherTransaction) {\n    const inputMapping = /* @__PURE__ */new Map();\n    const commandMapping = /* @__PURE__ */new Map();\n    for (let i = 0; i < otherTransaction.inputs.length; i++) {\n      const otherInput = otherTransaction.inputs[i];\n      const id = getIdFromCallArg(otherInput);\n      let existingIndex = -1;\n      if (id !== void 0) {\n        var _this$inputs$existing, _otherInput$Object;\n        existingIndex = this.inputs.findIndex(input => getIdFromCallArg(input) === id);\n        if (existingIndex !== -1 && (_this$inputs$existing = this.inputs[existingIndex].Object) !== null && _this$inputs$existing !== void 0 && _this$inputs$existing.SharedObject && (_otherInput$Object = otherInput.Object) !== null && _otherInput$Object !== void 0 && _otherInput$Object.SharedObject) {\n          this.inputs[existingIndex].Object.SharedObject.mutable = this.inputs[existingIndex].Object.SharedObject.mutable || otherInput.Object.SharedObject.mutable;\n        }\n      }\n      if (existingIndex !== -1) {\n        inputMapping.set(i, existingIndex);\n      } else {\n        const newIndex = this.inputs.length;\n        this.inputs.push(otherInput);\n        inputMapping.set(i, newIndex);\n      }\n    }\n    for (let i = 0; i < otherTransaction.commands.length; i++) {\n      commandMapping.set(i, atCommandIndex + i);\n    }\n    const remappedCommands = [];\n    for (let i = 0; i < otherTransaction.commands.length; i++) {\n      const command = structuredClone(otherTransaction.commands[i]);\n      remapCommandArguments(command, inputMapping, commandMapping);\n      remappedCommands.push(command);\n    }\n    this.commands.splice(atCommandIndex, 0, ...remappedCommands);\n    const sizeDiff = remappedCommands.length;\n    if (sizeDiff > 0) {\n      this.mapArguments((arg, _command, commandIndex) => {\n        if (commandIndex >= atCommandIndex && commandIndex < atCommandIndex + remappedCommands.length) {\n          return arg;\n        }\n        switch (arg.$kind) {\n          case \"Result\":\n            if (arg.Result >= atCommandIndex) {\n              arg.Result += sizeDiff;\n            }\n            break;\n          case \"NestedResult\":\n            if (arg.NestedResult[0] >= atCommandIndex) {\n              arg.NestedResult[0] += sizeDiff;\n            }\n            break;\n        }\n        return arg;\n      });\n    }\n  }\n  getDigest() {\n    const bytes = this.build({\n      onlyTransactionKind: false\n    });\n    return TransactionDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return parse(TransactionDataSchema, this);\n  }\n  shallowClone() {\n    return new TransactionDataBuilder({\n      version: this.version,\n      sender: this.sender,\n      expiration: this.expiration,\n      gasData: _objectSpread({}, this.gasData),\n      inputs: [...this.inputs],\n      commands: [...this.commands]\n    });\n  }\n  applyResolvedData(resolved) {\n    if (!this.sender) {\n      var _resolved$sender;\n      this.sender = (_resolved$sender = resolved.sender) !== null && _resolved$sender !== void 0 ? _resolved$sender : null;\n    }\n    if (!this.expiration) {\n      var _resolved$expiration;\n      this.expiration = (_resolved$expiration = resolved.expiration) !== null && _resolved$expiration !== void 0 ? _resolved$expiration : null;\n    }\n    if (!this.gasData.budget) {\n      this.gasData.budget = resolved.gasData.budget;\n    }\n    if (!this.gasData.owner) {\n      var _resolved$gasData$own;\n      this.gasData.owner = (_resolved$gasData$own = resolved.gasData.owner) !== null && _resolved$gasData$own !== void 0 ? _resolved$gasData$own : null;\n    }\n    if (!this.gasData.payment) {\n      this.gasData.payment = resolved.gasData.payment;\n    }\n    if (!this.gasData.price) {\n      this.gasData.price = resolved.gasData.price;\n    }\n    for (let i = 0; i < this.inputs.length; i++) {\n      const input = this.inputs[i];\n      const resolvedInput = resolved.inputs[i];\n      switch (input.$kind) {\n        case \"UnresolvedPure\":\n          if (resolvedInput.$kind !== \"Pure\") {\n            throw new Error(\"Expected input at index \".concat(i, \" to resolve to a Pure argument, but got \").concat(JSON.stringify(resolvedInput)));\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n        case \"UnresolvedObject\":\n          if (resolvedInput.$kind !== \"Object\") {\n            throw new Error(\"Expected input at index \".concat(i, \" to resolve to an Object argument, but got \").concat(JSON.stringify(resolvedInput)));\n          }\n          if (resolvedInput.Object.$kind === \"ImmOrOwnedObject\" || resolvedInput.Object.$kind === \"Receiving\") {\n            var _resolvedInput$Object;\n            const original = input.UnresolvedObject;\n            const resolved2 = (_resolvedInput$Object = resolvedInput.Object.ImmOrOwnedObject) !== null && _resolvedInput$Object !== void 0 ? _resolvedInput$Object : resolvedInput.Object.Receiving;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.version != null && original.version !== resolved2.version || original.digest != null && original.digest !== resolved2.digest ||\n            // Objects with shared object properties should not resolve to owned objects\n            original.mutable != null || original.initialSharedVersion != null) {\n              throw new Error(\"Input at index \".concat(i, \" did not match unresolved object. \").concat(JSON.stringify(original), \" is not compatible with \").concat(JSON.stringify(resolved2)));\n            }\n          } else if (resolvedInput.Object.$kind === \"SharedObject\") {\n            const original = input.UnresolvedObject;\n            const resolved2 = resolvedInput.Object.SharedObject;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.initialSharedVersion != null && original.initialSharedVersion !== resolved2.initialSharedVersion || original.mutable != null && original.mutable !== resolved2.mutable ||\n            // Objects with owned object properties should not resolve to shared objects\n            original.version != null || original.digest != null) {\n              throw new Error(\"Input at index \".concat(i, \" did not match unresolved object. \").concat(JSON.stringify(original), \" is not compatible with \").concat(JSON.stringify(resolved2)));\n            }\n          } else {\n            throw new Error(\"Input at index \".concat(i, \" resolved to an unexpected Object kind: \").concat(JSON.stringify(resolvedInput.Object)));\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n      }\n    }\n  }\n}\nexport { TransactionDataBuilder };\n//# sourceMappingURL=TransactionData.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}