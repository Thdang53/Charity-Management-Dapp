{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"transaction\", \"signer\"],\n  _excluded2 = [\"format\"],\n  _excluded3 = [\"signal\", \"timeout\", \"pollInterval\"];\nimport { fromBase58, toBase64, toHex } from \"@mysten/bcs\";\nimport { Experimental_BaseClient } from \"../experimental/client.js\";\nimport { isTransaction } from \"../transactions/Transaction.js\";\nimport { isValidSuiAddress, isValidSuiObjectId, isValidTransactionDigest, normalizeSuiAddress, normalizeSuiObjectId } from \"../utils/sui-types.js\";\nimport { normalizeSuiNSName } from \"../utils/suins.js\";\nimport { JsonRpcHTTPTransport } from \"./http-transport.js\";\nimport { isValidNamedPackage } from \"../utils/move-registry.js\";\nimport { hasMvrName } from \"../experimental/mvr.js\";\nimport { JSONRpcCoreClient } from \"./core.js\";\nconst SUI_CLIENT_BRAND = Symbol.for(\"@mysten/SuiClient\");\nfunction isSuiJsonRpcClient(client) {\n  return typeof client === \"object\" && client !== null && client[SUI_CLIENT_BRAND] === true;\n}\nclass SuiJsonRpcClient extends Experimental_BaseClient {\n  /**\n   * Establish a connection to a Sui RPC endpoint\n   *\n   * @param options configuration options for the API Client\n   */\n  constructor(options) {\n    var _options$network, _options$transport;\n    super({\n      network: (_options$network = options.network) !== null && _options$network !== void 0 ? _options$network : \"unknown\"\n    });\n    this.jsonRpc = this;\n    this.transport = (_options$transport = options.transport) !== null && _options$transport !== void 0 ? _options$transport : new JsonRpcHTTPTransport({\n      url: options.url\n    });\n    this.core = new JSONRpcCoreClient({\n      jsonRpcClient: this,\n      mvr: options.mvr\n    });\n  }\n  get [SUI_CLIENT_BRAND]() {\n    return true;\n  }\n  async getRpcApiVersion() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resp = await this.transport.request({\n      method: \"rpc.discover\",\n      params: [],\n      signal\n    });\n    return resp.info.version;\n  }\n  /**\n   * Get all Coin<`coin_type`> objects owned by an address.\n   */\n  async getCoins(_ref) {\n    let {\n      coinType,\n      owner,\n      cursor,\n      limit,\n      signal\n    } = _ref;\n    if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    if (coinType && hasMvrName(coinType)) {\n      coinType = (await this.core.mvr.resolveType({\n        type: coinType\n      })).type;\n    }\n    return await this.transport.request({\n      method: \"suix_getCoins\",\n      params: [owner, coinType, cursor, limit],\n      signal\n    });\n  }\n  /**\n   * Get all Coin objects owned by an address.\n   */\n  async getAllCoins(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getAllCoins\",\n      params: [input.owner, input.cursor, input.limit],\n      signal: input.signal\n    });\n  }\n  /**\n   * Get the total coin balance for one coin type, owned by the address owner.\n   */\n  async getBalance(_ref2) {\n    let {\n      owner,\n      coinType,\n      signal\n    } = _ref2;\n    if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    if (coinType && hasMvrName(coinType)) {\n      coinType = (await this.core.mvr.resolveType({\n        type: coinType\n      })).type;\n    }\n    return await this.transport.request({\n      method: \"suix_getBalance\",\n      params: [owner, coinType],\n      signal\n    });\n  }\n  /**\n   * Get the total coin balance for all coin types, owned by the address owner.\n   */\n  async getAllBalances(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getAllBalances\",\n      params: [input.owner],\n      signal: input.signal\n    });\n  }\n  /**\n   * Fetch CoinMetadata for a given coin type\n   */\n  async getCoinMetadata(_ref3) {\n    let {\n      coinType,\n      signal\n    } = _ref3;\n    if (coinType && hasMvrName(coinType)) {\n      coinType = (await this.core.mvr.resolveType({\n        type: coinType\n      })).type;\n    }\n    return await this.transport.request({\n      method: \"suix_getCoinMetadata\",\n      params: [coinType],\n      signal\n    });\n  }\n  /**\n   *  Fetch total supply for a coin\n   */\n  async getTotalSupply(_ref4) {\n    let {\n      coinType,\n      signal\n    } = _ref4;\n    if (coinType && hasMvrName(coinType)) {\n      coinType = (await this.core.mvr.resolveType({\n        type: coinType\n      })).type;\n    }\n    return await this.transport.request({\n      method: \"suix_getTotalSupply\",\n      params: [coinType],\n      signal\n    });\n  }\n  /**\n   * Invoke any RPC method\n   * @param method the method to be invoked\n   * @param args the arguments to be passed to the RPC request\n   */\n  async call(method, params) {\n    let {\n      signal\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return await this.transport.request({\n      method,\n      params,\n      signal\n    });\n  }\n  /**\n   * Get Move function argument types like read, write and full access\n   */\n  async getMoveFunctionArgTypes(_ref5) {\n    let {\n      package: pkg,\n      module,\n      function: fn,\n      signal\n    } = _ref5;\n    if (pkg && isValidNamedPackage(pkg)) {\n      pkg = (await this.core.mvr.resolvePackage({\n        package: pkg\n      })).package;\n    }\n    return await this.transport.request({\n      method: \"sui_getMoveFunctionArgTypes\",\n      params: [pkg, module, fn],\n      signal\n    });\n  }\n  /**\n   * Get a map from module name to\n   * structured representations of Move modules\n   */\n  async getNormalizedMoveModulesByPackage(_ref6) {\n    let {\n      package: pkg,\n      signal\n    } = _ref6;\n    if (pkg && isValidNamedPackage(pkg)) {\n      pkg = (await this.core.mvr.resolvePackage({\n        package: pkg\n      })).package;\n    }\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveModulesByPackage\",\n      params: [pkg],\n      signal\n    });\n  }\n  /**\n   * Get a structured representation of Move module\n   */\n  async getNormalizedMoveModule(_ref7) {\n    let {\n      package: pkg,\n      module,\n      signal\n    } = _ref7;\n    if (pkg && isValidNamedPackage(pkg)) {\n      pkg = (await this.core.mvr.resolvePackage({\n        package: pkg\n      })).package;\n    }\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveModule\",\n      params: [pkg, module],\n      signal\n    });\n  }\n  /**\n   * Get a structured representation of Move function\n   */\n  async getNormalizedMoveFunction(_ref8) {\n    let {\n      package: pkg,\n      module,\n      function: fn,\n      signal\n    } = _ref8;\n    if (pkg && isValidNamedPackage(pkg)) {\n      pkg = (await this.core.mvr.resolvePackage({\n        package: pkg\n      })).package;\n    }\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveFunction\",\n      params: [pkg, module, fn],\n      signal\n    });\n  }\n  /**\n   * Get a structured representation of Move struct\n   */\n  async getNormalizedMoveStruct(_ref9) {\n    let {\n      package: pkg,\n      module,\n      struct,\n      signal\n    } = _ref9;\n    if (pkg && isValidNamedPackage(pkg)) {\n      pkg = (await this.core.mvr.resolvePackage({\n        package: pkg\n      })).package;\n    }\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveStruct\",\n      params: [pkg, module, struct],\n      signal\n    });\n  }\n  /**\n   * Get all objects owned by an address\n   */\n  async getOwnedObjects(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    const filter = input.filter ? _objectSpread({}, input.filter) : void 0;\n    if (filter && \"MoveModule\" in filter && isValidNamedPackage(filter.MoveModule.package)) {\n      filter.MoveModule = {\n        module: filter.MoveModule.module,\n        package: (await this.core.mvr.resolvePackage({\n          package: filter.MoveModule.package\n        })).package\n      };\n    } else if (filter && \"StructType\" in filter && hasMvrName(filter.StructType)) {\n      filter.StructType = (await this.core.mvr.resolveType({\n        type: filter.StructType\n      })).type;\n    }\n    return await this.transport.request({\n      method: \"suix_getOwnedObjects\",\n      params: [input.owner, {\n        filter,\n        options: input.options\n      }, input.cursor, input.limit],\n      signal: input.signal\n    });\n  }\n  /**\n   * Get details about an object\n   */\n  async getObject(input) {\n    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.transport.request({\n      method: \"sui_getObject\",\n      params: [input.id, input.options],\n      signal: input.signal\n    });\n  }\n  async tryGetPastObject(input) {\n    return await this.transport.request({\n      method: \"sui_tryGetPastObject\",\n      params: [input.id, input.version, input.options],\n      signal: input.signal\n    });\n  }\n  /**\n   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n   */\n  async multiGetObjects(input) {\n    input.ids.forEach(id => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(\"Invalid Sui Object id \".concat(id));\n      }\n    });\n    const hasDuplicates = input.ids.length !== new Set(input.ids).size;\n    if (hasDuplicates) {\n      throw new Error(\"Duplicate object ids in batch call \".concat(input.ids));\n    }\n    return await this.transport.request({\n      method: \"sui_multiGetObjects\",\n      params: [input.ids, input.options],\n      signal: input.signal\n    });\n  }\n  /**\n   * Get transaction blocks for a given query criteria\n   */\n  async queryTransactionBlocks(_ref0) {\n    let {\n      filter,\n      options,\n      cursor,\n      limit,\n      order,\n      signal\n    } = _ref0;\n    if (filter && \"MoveFunction\" in filter && isValidNamedPackage(filter.MoveFunction.package)) {\n      filter = _objectSpread(_objectSpread({}, filter), {}, {\n        MoveFunction: {\n          package: (await this.core.mvr.resolvePackage({\n            package: filter.MoveFunction.package\n          })).package\n        }\n      });\n    }\n    return await this.transport.request({\n      method: \"suix_queryTransactionBlocks\",\n      params: [{\n        filter,\n        options\n      }, cursor, limit, (order || \"descending\") === \"descending\"],\n      signal\n    });\n  }\n  async getTransactionBlock(input) {\n    if (!isValidTransactionDigest(input.digest)) {\n      throw new Error(\"Invalid Transaction digest\");\n    }\n    return await this.transport.request({\n      method: \"sui_getTransactionBlock\",\n      params: [input.digest, input.options],\n      signal: input.signal\n    });\n  }\n  async multiGetTransactionBlocks(input) {\n    input.digests.forEach(d => {\n      if (!isValidTransactionDigest(d)) {\n        throw new Error(\"Invalid Transaction digest \".concat(d));\n      }\n    });\n    const hasDuplicates = input.digests.length !== new Set(input.digests).size;\n    if (hasDuplicates) {\n      throw new Error(\"Duplicate digests in batch call \".concat(input.digests));\n    }\n    return await this.transport.request({\n      method: \"sui_multiGetTransactionBlocks\",\n      params: [input.digests, input.options],\n      signal: input.signal\n    });\n  }\n  async executeTransactionBlock(_ref1) {\n    let {\n      transactionBlock,\n      signature,\n      options,\n      requestType,\n      signal\n    } = _ref1;\n    const result = await this.transport.request({\n      method: \"sui_executeTransactionBlock\",\n      params: [typeof transactionBlock === \"string\" ? transactionBlock : toBase64(transactionBlock), Array.isArray(signature) ? signature : [signature], options],\n      signal\n    });\n    if (requestType === \"WaitForLocalExecution\") {\n      try {\n        await this.waitForTransaction({\n          digest: result.digest\n        });\n      } catch (_unused) {}\n    }\n    return result;\n  }\n  async signAndExecuteTransaction(_ref10) {\n    let {\n        transaction,\n        signer\n      } = _ref10,\n      input = _objectWithoutProperties(_ref10, _excluded);\n    let transactionBytes;\n    if (transaction instanceof Uint8Array) {\n      transactionBytes = transaction;\n    } else {\n      transaction.setSenderIfNotSet(signer.toSuiAddress());\n      transactionBytes = await transaction.build({\n        client: this\n      });\n    }\n    const {\n      signature,\n      bytes\n    } = await signer.signTransaction(transactionBytes);\n    return this.executeTransactionBlock(_objectSpread({\n      transactionBlock: bytes,\n      signature\n    }, input));\n  }\n  /**\n   * Get total number of transactions\n   */\n  async getTotalTransactionBlocks() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resp = await this.transport.request({\n      method: \"sui_getTotalTransactionBlocks\",\n      params: [],\n      signal\n    });\n    return BigInt(resp);\n  }\n  /**\n   * Getting the reference gas price for the network\n   */\n  async getReferenceGasPrice() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resp = await this.transport.request({\n      method: \"suix_getReferenceGasPrice\",\n      params: [],\n      signal\n    });\n    return BigInt(resp);\n  }\n  /**\n   * Return the delegated stakes for an address\n   */\n  async getStakes(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getStakes\",\n      params: [input.owner],\n      signal: input.signal\n    });\n  }\n  /**\n   * Return the delegated stakes queried by id.\n   */\n  async getStakesByIds(input) {\n    input.stakedSuiIds.forEach(id => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(\"Invalid Sui Stake id \".concat(id));\n      }\n    });\n    return await this.transport.request({\n      method: \"suix_getStakesByIds\",\n      params: [input.stakedSuiIds],\n      signal: input.signal\n    });\n  }\n  /**\n   * Return the latest system state content.\n   */\n  async getLatestSuiSystemState() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.transport.request({\n      method: \"suix_getLatestSuiSystemState\",\n      params: [],\n      signal\n    });\n  }\n  /**\n   * Get events for a given query criteria\n   */\n  async queryEvents(_ref11) {\n    let {\n      query,\n      cursor,\n      limit,\n      order,\n      signal\n    } = _ref11;\n    if (query && \"MoveEventType\" in query && hasMvrName(query.MoveEventType)) {\n      query = _objectSpread(_objectSpread({}, query), {}, {\n        MoveEventType: (await this.core.mvr.resolveType({\n          type: query.MoveEventType\n        })).type\n      });\n    }\n    if (query && \"MoveEventModule\" in query && isValidNamedPackage(query.MoveEventModule.package)) {\n      query = _objectSpread(_objectSpread({}, query), {}, {\n        MoveEventModule: {\n          module: query.MoveEventModule.module,\n          package: (await this.core.mvr.resolvePackage({\n            package: query.MoveEventModule.package\n          })).package\n        }\n      });\n    }\n    if (\"MoveModule\" in query && isValidNamedPackage(query.MoveModule.package)) {\n      query = _objectSpread(_objectSpread({}, query), {}, {\n        MoveModule: {\n          module: query.MoveModule.module,\n          package: (await this.core.mvr.resolvePackage({\n            package: query.MoveModule.package\n          })).package\n        }\n      });\n    }\n    return await this.transport.request({\n      method: \"suix_queryEvents\",\n      params: [query, cursor, limit, (order || \"descending\") === \"descending\"],\n      signal\n    });\n  }\n  /**\n   * Subscribe to get notifications whenever an event matching the filter occurs\n   *\n   * @deprecated\n   */\n  async subscribeEvent(input) {\n    return this.transport.subscribe({\n      method: \"suix_subscribeEvent\",\n      unsubscribe: \"suix_unsubscribeEvent\",\n      params: [input.filter],\n      onMessage: input.onMessage,\n      signal: input.signal\n    });\n  }\n  /**\n   * @deprecated\n   */\n  async subscribeTransaction(input) {\n    return this.transport.subscribe({\n      method: \"suix_subscribeTransaction\",\n      unsubscribe: \"suix_unsubscribeTransaction\",\n      params: [input.filter],\n      onMessage: input.onMessage,\n      signal: input.signal\n    });\n  }\n  /**\n   * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n   * transaction (or Move call) with any arguments. Detailed results are\n   * provided, including both the transaction effects and any return values.\n   */\n  async devInspectTransactionBlock(input) {\n    var _input$signal, _input$gasPrice;\n    let devInspectTxBytes;\n    if (isTransaction(input.transactionBlock)) {\n      input.transactionBlock.setSenderIfNotSet(input.sender);\n      devInspectTxBytes = toBase64(await input.transactionBlock.build({\n        client: this,\n        onlyTransactionKind: true\n      }));\n    } else if (typeof input.transactionBlock === \"string\") {\n      devInspectTxBytes = input.transactionBlock;\n    } else if (input.transactionBlock instanceof Uint8Array) {\n      devInspectTxBytes = toBase64(input.transactionBlock);\n    } else {\n      throw new Error(\"Unknown transaction block format.\");\n    }\n    (_input$signal = input.signal) === null || _input$signal === void 0 || _input$signal.throwIfAborted();\n    return await this.transport.request({\n      method: \"sui_devInspectTransactionBlock\",\n      params: [input.sender, devInspectTxBytes, (_input$gasPrice = input.gasPrice) === null || _input$gasPrice === void 0 ? void 0 : _input$gasPrice.toString(), input.epoch],\n      signal: input.signal\n    });\n  }\n  /**\n   * Dry run a transaction block and return the result.\n   */\n  async dryRunTransactionBlock(input) {\n    return await this.transport.request({\n      method: \"sui_dryRunTransactionBlock\",\n      params: [typeof input.transactionBlock === \"string\" ? input.transactionBlock : toBase64(input.transactionBlock)]\n    });\n  }\n  /**\n   * Return the list of dynamic field objects owned by an object\n   */\n  async getDynamicFields(input) {\n    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.transport.request({\n      method: \"suix_getDynamicFields\",\n      params: [input.parentId, input.cursor, input.limit],\n      signal: input.signal\n    });\n  }\n  /**\n   * Return the dynamic field object information for a specified object\n   */\n  async getDynamicFieldObject(input) {\n    return await this.transport.request({\n      method: \"suix_getDynamicFieldObject\",\n      params: [input.parentId, input.name],\n      signal: input.signal\n    });\n  }\n  /**\n   * Get the sequence number of the latest checkpoint that has been executed\n   */\n  async getLatestCheckpointSequenceNumber() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resp = await this.transport.request({\n      method: \"sui_getLatestCheckpointSequenceNumber\",\n      params: [],\n      signal\n    });\n    return String(resp);\n  }\n  /**\n   * Returns information about a given checkpoint\n   */\n  async getCheckpoint(input) {\n    return await this.transport.request({\n      method: \"sui_getCheckpoint\",\n      params: [input.id],\n      signal: input.signal\n    });\n  }\n  /**\n   * Returns historical checkpoints paginated\n   */\n  async getCheckpoints(input) {\n    return await this.transport.request({\n      method: \"sui_getCheckpoints\",\n      params: [input.cursor, input === null || input === void 0 ? void 0 : input.limit, input.descendingOrder],\n      signal: input.signal\n    });\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCommitteeInfo(input) {\n    return await this.transport.request({\n      method: \"suix_getCommitteeInfo\",\n      params: [input === null || input === void 0 ? void 0 : input.epoch],\n      signal: input === null || input === void 0 ? void 0 : input.signal\n    });\n  }\n  async getNetworkMetrics() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.transport.request({\n      method: \"suix_getNetworkMetrics\",\n      params: [],\n      signal\n    });\n  }\n  async getAddressMetrics() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.transport.request({\n      method: \"suix_getLatestAddressMetrics\",\n      params: [],\n      signal\n    });\n  }\n  async getEpochMetrics(input) {\n    return await this.transport.request({\n      method: \"suix_getEpochMetrics\",\n      params: [input === null || input === void 0 ? void 0 : input.cursor, input === null || input === void 0 ? void 0 : input.limit, input === null || input === void 0 ? void 0 : input.descendingOrder],\n      signal: input === null || input === void 0 ? void 0 : input.signal\n    });\n  }\n  async getAllEpochAddressMetrics(input) {\n    return await this.transport.request({\n      method: \"suix_getAllEpochAddressMetrics\",\n      params: [input === null || input === void 0 ? void 0 : input.descendingOrder],\n      signal: input === null || input === void 0 ? void 0 : input.signal\n    });\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getEpochs(input) {\n    return await this.transport.request({\n      method: \"suix_getEpochs\",\n      params: [input === null || input === void 0 ? void 0 : input.cursor, input === null || input === void 0 ? void 0 : input.limit, input === null || input === void 0 ? void 0 : input.descendingOrder],\n      signal: input === null || input === void 0 ? void 0 : input.signal\n    });\n  }\n  /**\n   * Returns list of top move calls by usage\n   */\n  async getMoveCallMetrics() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.transport.request({\n      method: \"suix_getMoveCallMetrics\",\n      params: [],\n      signal\n    });\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCurrentEpoch() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.transport.request({\n      method: \"suix_getCurrentEpoch\",\n      params: [],\n      signal\n    });\n  }\n  /**\n   * Return the Validators APYs\n   */\n  async getValidatorsApy() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.transport.request({\n      method: \"suix_getValidatorsApy\",\n      params: [],\n      signal\n    });\n  }\n  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n  async getChainIdentifier() {\n    let {\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const checkpoint = await this.getCheckpoint({\n      id: \"0\",\n      signal\n    });\n    const bytes = fromBase58(checkpoint.digest);\n    return toHex(bytes.slice(0, 4));\n  }\n  async resolveNameServiceAddress(input) {\n    return await this.transport.request({\n      method: \"suix_resolveNameServiceAddress\",\n      params: [input.name],\n      signal: input.signal\n    });\n  }\n  async resolveNameServiceNames(_ref12) {\n    let {\n        format = \"dot\"\n      } = _ref12,\n      input = _objectWithoutProperties(_ref12, _excluded2);\n    const {\n      nextCursor,\n      hasNextPage,\n      data\n    } = await this.transport.request({\n      method: \"suix_resolveNameServiceNames\",\n      params: [input.address, input.cursor, input.limit],\n      signal: input.signal\n    });\n    return {\n      hasNextPage,\n      nextCursor,\n      data: data.map(name => normalizeSuiNSName(name, format))\n    };\n  }\n  async getProtocolConfig(input) {\n    return await this.transport.request({\n      method: \"sui_getProtocolConfig\",\n      params: [input === null || input === void 0 ? void 0 : input.version],\n      signal: input === null || input === void 0 ? void 0 : input.signal\n    });\n  }\n  async verifyZkLoginSignature(input) {\n    return await this.transport.request({\n      method: \"sui_verifyZkLoginSignature\",\n      params: [input.bytes, input.signature, input.intentScope, input.author],\n      signal: input.signal\n    });\n  }\n  /**\n   * Wait for a transaction block result to be available over the API.\n   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n   * be available via the API.\n   * This currently polls the `getTransactionBlock` API to check for the transaction.\n   */\n  async waitForTransaction(_ref13) {\n    let {\n        signal,\n        timeout = 60 * 1e3,\n        pollInterval = 2 * 1e3\n      } = _ref13,\n      input = _objectWithoutProperties(_ref13, _excluded3);\n    const timeoutSignal = AbortSignal.timeout(timeout);\n    const timeoutPromise = new Promise((_, reject) => {\n      timeoutSignal.addEventListener(\"abort\", () => reject(timeoutSignal.reason));\n    });\n    timeoutPromise.catch(() => {});\n    while (!timeoutSignal.aborted) {\n      signal === null || signal === void 0 || signal.throwIfAborted();\n      try {\n        return await this.getTransactionBlock(input);\n      } catch (_unused2) {\n        await Promise.race([new Promise(resolve => setTimeout(resolve, pollInterval)), timeoutPromise]);\n      }\n    }\n    timeoutSignal.throwIfAborted();\n    throw new Error(\"Unexpected error while waiting for transaction block.\");\n  }\n}\nexport { SuiJsonRpcClient, isSuiJsonRpcClient };\n//# sourceMappingURL=client.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}