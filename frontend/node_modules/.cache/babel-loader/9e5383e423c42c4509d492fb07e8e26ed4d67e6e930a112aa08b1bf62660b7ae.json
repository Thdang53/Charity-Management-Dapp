{"ast":null,"code":"import _objectSpread from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"client\"],\n  _excluded2 = [\"transaction\"],\n  _excluded3 = [\"transaction\", \"options\"],\n  _excluded4 = [\"options\", \"transaction\"];\nvar __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _client, _lastDigest;\nimport { bcs } from \"../../bcs/index.js\";\nimport { ObjectCache } from \"../ObjectCache.js\";\nimport { isTransaction } from \"../Transaction.js\";\nclass CachingTransactionExecutor {\n  constructor(_ref) {\n    let {\n        client\n      } = _ref,\n      options = _objectWithoutProperties(_ref, _excluded);\n    __privateAdd(this, _client);\n    __privateAdd(this, _lastDigest, null);\n    __privateSet(this, _client, client);\n    this.cache = new ObjectCache(options);\n  }\n  /**\n   * Clears all Owned objects\n   * Immutable objects, Shared objects, and Move function definitions will be preserved\n   */\n  async reset() {\n    await Promise.all([this.cache.clearOwnedObjects(), this.cache.clearCustom(), this.waitForLastTransaction()]);\n  }\n  async buildTransaction(_ref2) {\n    let {\n        transaction\n      } = _ref2,\n      options = _objectWithoutProperties(_ref2, _excluded2);\n    transaction.addBuildPlugin(this.cache.asPlugin());\n    return transaction.build(_objectSpread({\n      client: __privateGet(this, _client)\n    }, options));\n  }\n  async executeTransaction(_ref3) {\n    let {\n        transaction,\n        options\n      } = _ref3,\n      input = _objectWithoutProperties(_ref3, _excluded3);\n    const bytes = isTransaction(transaction) ? await this.buildTransaction({\n      transaction\n    }) : transaction;\n    const results = await __privateGet(this, _client).executeTransactionBlock(_objectSpread(_objectSpread({}, input), {}, {\n      transactionBlock: bytes,\n      options: _objectSpread(_objectSpread({}, options), {}, {\n        showRawEffects: true\n      })\n    }));\n    if (results.rawEffects) {\n      const effects = bcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));\n      await this.applyEffects(effects);\n    }\n    return results;\n  }\n  async signAndExecuteTransaction(_ref4) {\n    let {\n        options,\n        transaction\n      } = _ref4,\n      input = _objectWithoutProperties(_ref4, _excluded4);\n    transaction.setSenderIfNotSet(input.signer.toSuiAddress());\n    const bytes = await this.buildTransaction({\n      transaction\n    });\n    const {\n      signature\n    } = await input.signer.signTransaction(bytes);\n    const results = await this.executeTransaction({\n      transaction: bytes,\n      signature,\n      options\n    });\n    return results;\n  }\n  async applyEffects(effects) {\n    var _effects$V2$transacti, _effects$V;\n    __privateSet(this, _lastDigest, (_effects$V2$transacti = (_effects$V = effects.V2) === null || _effects$V === void 0 ? void 0 : _effects$V.transactionDigest) !== null && _effects$V2$transacti !== void 0 ? _effects$V2$transacti : null);\n    await this.cache.applyEffects(effects);\n  }\n  async waitForLastTransaction() {\n    if (__privateGet(this, _lastDigest)) {\n      await __privateGet(this, _client).waitForTransaction({\n        digest: __privateGet(this, _lastDigest)\n      });\n      __privateSet(this, _lastDigest, null);\n    }\n  }\n}\n_client = new WeakMap();\n_lastDigest = new WeakMap();\nexport { CachingTransactionExecutor };\n//# sourceMappingURL=caching.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}