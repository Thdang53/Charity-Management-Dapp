{"ast":null,"code":"\"use client\";\n\n// src/popper.tsx\nimport _objectSpread from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"__scopePopper\", \"virtualRef\"],\n  _excluded2 = [\"__scopePopper\", \"side\", \"sideOffset\", \"align\", \"alignOffset\", \"arrowPadding\", \"avoidCollisions\", \"collisionBoundary\", \"collisionPadding\", \"sticky\", \"hideWhenDetached\", \"updatePositionStrategy\", \"onPlaced\"],\n  _excluded3 = [\"__scopePopper\"];\nimport * as React from \"react\";\nimport { useFloating, autoUpdate, offset, shift, limitShift, hide, arrow as floatingUIarrow, flip, size } from \"@floating-ui/react-dom\";\nimport * as ArrowPrimitive from \"@radix-ui/react-arrow\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { jsx } from \"react/jsx-runtime\";\nvar SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nvar ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nvar POPPER_NAME = \"Popper\";\nvar [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\nvar [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);\nvar Popper = props => {\n  const {\n    __scopePopper,\n    children\n  } = props;\n  const [anchor, setAnchor] = React.useState(null);\n  return /* @__PURE__ */jsx(PopperProvider, {\n    scope: __scopePopper,\n    anchor,\n    onAnchorChange: setAnchor,\n    children\n  });\n};\nPopper.displayName = POPPER_NAME;\nvar ANCHOR_NAME = \"PopperAnchor\";\nvar PopperAnchor = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopePopper,\n      virtualRef\n    } = props,\n    anchorProps = _objectWithoutProperties(props, _excluded);\n  const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const anchorRef = React.useRef(null);\n  React.useEffect(() => {\n    const previousAnchor = anchorRef.current;\n    anchorRef.current = (virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current;\n    if (previousAnchor !== anchorRef.current) {\n      context.onAnchorChange(anchorRef.current);\n    }\n  });\n  return virtualRef ? null : /* @__PURE__ */jsx(Primitive.div, _objectSpread(_objectSpread({}, anchorProps), {}, {\n    ref: composedRefs\n  }));\n});\nPopperAnchor.displayName = ANCHOR_NAME;\nvar CONTENT_NAME = \"PopperContent\";\nvar [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);\nvar PopperContent = React.forwardRef((props, forwardedRef) => {\n  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;\n  const {\n      __scopePopper,\n      side = \"bottom\",\n      sideOffset = 0,\n      align = \"center\",\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = \"partial\",\n      hideWhenDetached = false,\n      updatePositionStrategy = \"optimized\",\n      onPlaced\n    } = props,\n    contentProps = _objectWithoutProperties(props, _excluded2);\n  const context = usePopperContext(CONTENT_NAME, __scopePopper);\n  const [content, setContent] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setContent(node));\n  const [arrow, setArrow] = React.useState(null);\n  const arrowSize = useSize(arrow);\n  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;\n  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;\n  const desiredPlacement = side + (align !== \"center\" ? \"-\" + align : \"\");\n  const collisionPadding = typeof collisionPaddingProp === \"number\" ? collisionPaddingProp : _objectSpread({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, collisionPaddingProp);\n  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n  const hasExplicitBoundaries = boundary.length > 0;\n  const detectOverflowOptions = {\n    padding: collisionPadding,\n    boundary: boundary.filter(isNotNull),\n    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n    altBoundary: hasExplicitBoundaries\n  };\n  const {\n    refs,\n    floatingStyles,\n    placement,\n    isPositioned,\n    middlewareData\n  } = useFloating({\n    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n    strategy: \"fixed\",\n    placement: desiredPlacement,\n    whileElementsMounted: function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const cleanup = autoUpdate(...args, {\n        animationFrame: updatePositionStrategy === \"always\"\n      });\n      return cleanup;\n    },\n    elements: {\n      reference: context.anchor\n    },\n    middleware: [offset({\n      mainAxis: sideOffset + arrowHeight,\n      alignmentAxis: alignOffset\n    }), avoidCollisions && shift(_objectSpread({\n      mainAxis: true,\n      crossAxis: false,\n      limiter: sticky === \"partial\" ? limitShift() : void 0\n    }, detectOverflowOptions)), avoidCollisions && flip(_objectSpread({}, detectOverflowOptions)), size(_objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n      apply: _ref => {\n        let {\n          elements,\n          rects,\n          availableWidth,\n          availableHeight\n        } = _ref;\n        const {\n          width: anchorWidth,\n          height: anchorHeight\n        } = rects.reference;\n        const contentStyle = elements.floating.style;\n        contentStyle.setProperty(\"--radix-popper-available-width\", \"\".concat(availableWidth, \"px\"));\n        contentStyle.setProperty(\"--radix-popper-available-height\", \"\".concat(availableHeight, \"px\"));\n        contentStyle.setProperty(\"--radix-popper-anchor-width\", \"\".concat(anchorWidth, \"px\"));\n        contentStyle.setProperty(\"--radix-popper-anchor-height\", \"\".concat(anchorHeight, \"px\"));\n      }\n    })), arrow && floatingUIarrow({\n      element: arrow,\n      padding: arrowPadding\n    }), transformOrigin({\n      arrowWidth,\n      arrowHeight\n    }), hideWhenDetached && hide(_objectSpread({\n      strategy: \"referenceHidden\"\n    }, detectOverflowOptions))]\n  });\n  const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n  const handlePlaced = useCallbackRef(onPlaced);\n  useLayoutEffect(() => {\n    if (isPositioned) {\n      handlePlaced === null || handlePlaced === void 0 || handlePlaced();\n    }\n  }, [isPositioned, handlePlaced]);\n  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;\n  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;\n  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;\n  const [contentZIndex, setContentZIndex] = React.useState();\n  useLayoutEffect(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: refs.setFloating,\n    \"data-radix-popper-content-wrapper\": \"\",\n    style: _objectSpread(_objectSpread({}, floatingStyles), {}, {\n      transform: isPositioned ? floatingStyles.transform : \"translate(0, -200%)\",\n      // keep off the page when measuring\n      minWidth: \"max-content\",\n      zIndex: contentZIndex,\n      [\"--radix-popper-transform-origin\"]: [(_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x, (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y].join(\" \")\n    }, ((_middlewareData$hide = middlewareData.hide) === null || _middlewareData$hide === void 0 ? void 0 : _middlewareData$hide.referenceHidden) && {\n      visibility: \"hidden\",\n      pointerEvents: \"none\"\n    }),\n    dir: props.dir,\n    children: /* @__PURE__ */jsx(PopperContentProvider, {\n      scope: __scopePopper,\n      placedSide,\n      onArrowChange: setArrow,\n      arrowX,\n      arrowY,\n      shouldHideArrow: cannotCenterArrow,\n      children: /* @__PURE__ */jsx(Primitive.div, _objectSpread(_objectSpread({\n        \"data-side\": placedSide,\n        \"data-align\": placedAlign\n      }, contentProps), {}, {\n        ref: composedRefs,\n        style: _objectSpread(_objectSpread({}, contentProps.style), {}, {\n          // if the PopperContent hasn't been placed yet (not all measurements done)\n          // we prevent animations so that users's animation don't kick in too early referring wrong sides\n          animation: !isPositioned ? \"none\" : void 0\n        })\n      }))\n    })\n  });\n});\nPopperContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"PopperArrow\";\nvar OPPOSITE_SIDE = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nvar PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {\n  const {\n      __scopePopper\n    } = props,\n    arrowProps = _objectWithoutProperties(props, _excluded3);\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    /* @__PURE__ */\n    jsx(\"span\", {\n      ref: contentContext.onArrowChange,\n      style: {\n        position: \"absolute\",\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: \"\",\n          right: \"0 0\",\n          bottom: \"center 0\",\n          left: \"100% 0\"\n        }[contentContext.placedSide],\n        transform: {\n          top: \"translateY(100%)\",\n          right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n          bottom: \"rotate(180deg)\",\n          left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? \"hidden\" : void 0\n      },\n      children: /* @__PURE__ */jsx(ArrowPrimitive.Root, _objectSpread(_objectSpread({}, arrowProps), {}, {\n        ref: forwardedRef,\n        style: _objectSpread(_objectSpread({}, arrowProps.style), {}, {\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: \"block\"\n        })\n      }))\n    })\n  );\n});\nPopperArrow.displayName = ARROW_NAME;\nfunction isNotNull(value) {\n  return value !== null;\n}\nvar transformOrigin = options => ({\n  name: \"transformOrigin\",\n  options,\n  fn(data) {\n    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;\n    const {\n      placement,\n      rects,\n      middlewareData\n    } = data;\n    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = {\n      start: \"0%\",\n      center: \"50%\",\n      end: \"100%\"\n    }[placedAlign];\n    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;\n    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;\n    let x = \"\";\n    let y = \"\";\n    if (placedSide === \"bottom\") {\n      x = isArrowHidden ? noArrowAlign : \"\".concat(arrowXCenter, \"px\");\n      y = \"\".concat(-arrowHeight, \"px\");\n    } else if (placedSide === \"top\") {\n      x = isArrowHidden ? noArrowAlign : \"\".concat(arrowXCenter, \"px\");\n      y = \"\".concat(rects.floating.height + arrowHeight, \"px\");\n    } else if (placedSide === \"right\") {\n      x = \"\".concat(-arrowHeight, \"px\");\n      y = isArrowHidden ? noArrowAlign : \"\".concat(arrowYCenter, \"px\");\n    } else if (placedSide === \"left\") {\n      x = \"\".concat(rects.floating.width + arrowHeight, \"px\");\n      y = isArrowHidden ? noArrowAlign : \"\".concat(arrowYCenter, \"px\");\n    }\n    return {\n      data: {\n        x,\n        y\n      }\n    };\n  }\n});\nfunction getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [side, align];\n}\nvar Root2 = Popper;\nvar Anchor = PopperAnchor;\nvar Content = PopperContent;\nvar Arrow = PopperArrow;\nexport { ALIGN_OPTIONS, Anchor, Arrow, Content, Popper, PopperAnchor, PopperArrow, PopperContent, Root2 as Root, SIDE_OPTIONS, createPopperScope };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}