{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"size\"],\n  _excluded2 = [\"readMethod\", \"writeMethod\"],\n  _excluded3 = [\"readMethod\", \"writeMethod\"],\n  _excluded4 = [\"serialize\"],\n  _excluded5 = [\"toBytes\", \"fromBytes\"];\nvar __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _write, _serialize, _schema, _bytes;\nimport { fromBase58, toBase58 } from \"./b58.js\";\nimport { fromBase64, toBase64 } from \"./b64.js\";\nimport { fromHex, toHex } from \"./hex.js\";\nimport { BcsReader } from \"./reader.js\";\nimport { ulebEncode } from \"./uleb.js\";\nimport { BcsWriter } from \"./writer.js\";\nconst _BcsType = class _BcsType {\n  constructor(options) {\n    var _options$serializedSi, _options$serialize, _options$validate;\n    __privateAdd(this, _write);\n    __privateAdd(this, _serialize);\n    this.name = options.name;\n    this.read = options.read;\n    this.serializedSize = (_options$serializedSi = options.serializedSize) !== null && _options$serializedSi !== void 0 ? _options$serializedSi : () => null;\n    __privateSet(this, _write, options.write);\n    __privateSet(this, _serialize, (_options$serialize = options.serialize) !== null && _options$serialize !== void 0 ? _options$serialize : (value, options2) => {\n      var _this$serializedSize;\n      const writer = new BcsWriter(_objectSpread({\n        initialSize: (_this$serializedSize = this.serializedSize(value)) !== null && _this$serializedSize !== void 0 ? _this$serializedSize : void 0\n      }, options2));\n      __privateGet(this, _write).call(this, value, writer);\n      return writer.toBytes();\n    });\n    this.validate = (_options$validate = options.validate) !== null && _options$validate !== void 0 ? _options$validate : () => {};\n  }\n  write(value, writer) {\n    this.validate(value);\n    __privateGet(this, _write).call(this, value, writer);\n  }\n  serialize(value, options) {\n    this.validate(value);\n    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n  }\n  parse(bytes) {\n    const reader = new BcsReader(bytes);\n    return this.read(reader);\n  }\n  fromHex(hex) {\n    return this.parse(fromHex(hex));\n  }\n  fromBase58(b64) {\n    return this.parse(fromBase58(b64));\n  }\n  fromBase64(b64) {\n    return this.parse(fromBase64(b64));\n  }\n  transform(_ref) {\n    let {\n      name,\n      input,\n      output,\n      validate\n    } = _ref;\n    return new _BcsType({\n      name: name !== null && name !== void 0 ? name : this.name,\n      read: reader => output ? output(this.read(reader)) : this.read(reader),\n      write: (value, writer) => __privateGet(this, _write).call(this, input ? input(value) : value, writer),\n      serializedSize: value => this.serializedSize(input ? input(value) : value),\n      serialize: (value, options) => __privateGet(this, _serialize).call(this, input ? input(value) : value, options),\n      validate: value => {\n        validate === null || validate === void 0 || validate(value);\n        this.validate(input ? input(value) : value);\n      }\n    });\n  }\n};\n_write = new WeakMap();\n_serialize = new WeakMap();\nlet BcsType = _BcsType;\nconst SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n  return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nclass SerializedBcs {\n  constructor(type, schema) {\n    __privateAdd(this, _schema);\n    __privateAdd(this, _bytes);\n    __privateSet(this, _schema, type);\n    __privateSet(this, _bytes, schema);\n  }\n  // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n  // of the @mysten/bcs package are installed\n  get [SERIALIZED_BCS_BRAND]() {\n    return true;\n  }\n  toBytes() {\n    return __privateGet(this, _bytes);\n  }\n  toHex() {\n    return toHex(__privateGet(this, _bytes));\n  }\n  toBase64() {\n    return toBase64(__privateGet(this, _bytes));\n  }\n  toBase58() {\n    return toBase58(__privateGet(this, _bytes));\n  }\n  parse() {\n    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n  }\n}\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType(_ref2) {\n  let {\n      size\n    } = _ref2,\n    options = _objectWithoutProperties(_ref2, _excluded);\n  return new BcsType(_objectSpread(_objectSpread({}, options), {}, {\n    serializedSize: () => size\n  }));\n}\nfunction uIntBcsType(_ref3) {\n  let {\n      readMethod,\n      writeMethod\n    } = _ref3,\n    options = _objectWithoutProperties(_ref3, _excluded2);\n  return fixedSizeBcsType(_objectSpread(_objectSpread({}, options), {}, {\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](value),\n    validate: value => {\n      var _options$validate2;\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\"Invalid \".concat(options.name, \" value: \").concat(value, \". Expected value in range 0-\").concat(options.maxValue));\n      }\n      (_options$validate2 = options.validate) === null || _options$validate2 === void 0 || _options$validate2.call(options, value);\n    }\n  }));\n}\nfunction bigUIntBcsType(_ref4) {\n  let {\n      readMethod,\n      writeMethod\n    } = _ref4,\n    options = _objectWithoutProperties(_ref4, _excluded3);\n  return fixedSizeBcsType(_objectSpread(_objectSpread({}, options), {}, {\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](BigInt(value)),\n    validate: val => {\n      var _options$validate3;\n      const value = BigInt(val);\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\"Invalid \".concat(options.name, \" value: \").concat(value, \". Expected value in range 0-\").concat(options.maxValue));\n      }\n      (_options$validate3 = options.validate) === null || _options$validate3 === void 0 || _options$validate3.call(options, value);\n    }\n  }));\n}\nfunction dynamicSizeBcsType(_ref5) {\n  let {\n      serialize\n    } = _ref5,\n    options = _objectWithoutProperties(_ref5, _excluded4);\n  const type = new BcsType(_objectSpread(_objectSpread({}, options), {}, {\n    serialize,\n    write: (value, writer) => {\n      for (const byte of type.serialize(value).toBytes()) {\n        writer.write8(byte);\n      }\n    }\n  }));\n  return type;\n}\nfunction stringLikeBcsType(_ref6) {\n  let {\n      toBytes,\n      fromBytes\n    } = _ref6,\n    options = _objectWithoutProperties(_ref6, _excluded5);\n  return new BcsType(_objectSpread(_objectSpread({}, options), {}, {\n    read: reader => {\n      const length = reader.readULEB();\n      const bytes = reader.readBytes(length);\n      return fromBytes(bytes);\n    },\n    write: (hex, writer) => {\n      const bytes = toBytes(hex);\n      writer.writeULEB(bytes.length);\n      for (let i = 0; i < bytes.length; i++) {\n        writer.write8(bytes[i]);\n      }\n    },\n    serialize: value => {\n      const bytes = toBytes(value);\n      const size = ulebEncode(bytes.length);\n      const result = new Uint8Array(size.length + bytes.length);\n      result.set(size, 0);\n      result.set(bytes, size.length);\n      return result;\n    },\n    validate: value => {\n      var _options$validate4;\n      if (typeof value !== \"string\") {\n        throw new TypeError(\"Invalid \".concat(options.name, \" value: \").concat(value, \". Expected string\"));\n      }\n      (_options$validate4 = options.validate) === null || _options$validate4 === void 0 || _options$validate4.call(options, value);\n    }\n  }));\n}\nfunction lazyBcsType(cb) {\n  let lazyType = null;\n  function getType() {\n    if (!lazyType) {\n      lazyType = cb();\n    }\n    return lazyType;\n  }\n  return new BcsType({\n    name: \"lazy\",\n    read: data => getType().read(data),\n    serializedSize: value => getType().serializedSize(value),\n    write: (value, writer) => getType().write(value, writer),\n    serialize: (value, options) => getType().serialize(value, options).toBytes()\n  });\n}\nexport { BcsType, SerializedBcs, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, isSerializedBcs, lazyBcsType, stringLikeBcsType, uIntBcsType };\n//# sourceMappingURL=bcs-type.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}