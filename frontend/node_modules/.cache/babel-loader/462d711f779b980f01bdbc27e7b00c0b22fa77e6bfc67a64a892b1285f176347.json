{"ast":null,"code":"import { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from \"../utils/index.js\";\nimport { ObjectRef } from \"./data/internal.js\";\nimport { Inputs } from \"./Inputs.js\";\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from \"./serializer.js\";\nconst MAX_OBJECTS_PER_FETCH = 50;\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 5e10;\nasync function resolveTransactionData(transactionData, options, next) {\n  await normalizeInputs(transactionData, options);\n  await resolveObjectReferences(transactionData, options);\n  if (!options.onlyTransactionKind) {\n    await setGasPrice(transactionData, options);\n    await setGasBudget(transactionData, options);\n    await setGasPayment(transactionData, options);\n  }\n  await validate(transactionData);\n  return await next();\n}\nasync function setGasPrice(transactionData, options) {\n  if (!transactionData.gasConfig.price) {\n    transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());\n  }\n}\nasync function setGasBudget(transactionData, options) {\n  if (transactionData.gasConfig.budget) {\n    return;\n  }\n  const dryRunResult = await getClient(options).dryRunTransactionBlock({\n    transactionBlock: transactionData.build({\n      overrides: {\n        gasData: {\n          budget: String(MAX_GAS),\n          payment: []\n        }\n      }\n    })\n  });\n  if (dryRunResult.effects.status.status !== \"success\") {\n    throw new Error(\"Dry run failed, could not automatically determine a budget: \".concat(dryRunResult.effects.status.error), {\n      cause: dryRunResult\n    });\n  }\n  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n  transactionData.gasConfig.budget = String(gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead);\n}\nasync function setGasPayment(transactionData, options) {\n  if (!transactionData.gasConfig.payment) {\n    const coins = await getClient(options).getCoins({\n      owner: transactionData.gasConfig.owner || transactionData.sender,\n      coinType: SUI_TYPE_ARG\n    });\n    const paymentCoins = coins.data.filter(coin => {\n      const matchingInput = transactionData.inputs.find(input => {\n        var _input$Object;\n        if ((_input$Object = input.Object) !== null && _input$Object !== void 0 && _input$Object.ImmOrOwnedObject) {\n          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n        }\n        return false;\n      });\n      return !matchingInput;\n    }).map(coin => ({\n      objectId: coin.coinObjectId,\n      digest: coin.digest,\n      version: coin.version\n    }));\n    if (!paymentCoins.length) {\n      throw new Error(\"No valid gas coins found for the transaction.\");\n    }\n    transactionData.gasConfig.payment = paymentCoins.map(payment => parse(ObjectRef, payment));\n  }\n}\nasync function resolveObjectReferences(transactionData, options) {\n  const objectsToResolve = transactionData.inputs.filter(input => {\n    var _input$UnresolvedObje;\n    return input.UnresolvedObject && !(input.UnresolvedObject.version || (_input$UnresolvedObje = input.UnresolvedObject) !== null && _input$UnresolvedObje !== void 0 && _input$UnresolvedObje.initialSharedVersion);\n  });\n  const dedupedIds = [...new Set(objectsToResolve.map(input => normalizeSuiObjectId(input.UnresolvedObject.objectId)))];\n  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n  const resolved = (await Promise.all(objectChunks.map(chunk2 => getClient(options).multiGetObjects({\n    ids: chunk2,\n    options: {\n      showOwner: true\n    }\n  })))).flat();\n  const responsesById = new Map(dedupedIds.map((id, index) => {\n    return [id, resolved[index]];\n  }));\n  const invalidObjects = Array.from(responsesById).filter(_ref => {\n    let [_, obj] = _ref;\n    return obj.error;\n  }).map(_ref2 => {\n    let [_, obj] = _ref2;\n    return JSON.stringify(obj.error);\n  });\n  if (invalidObjects.length) {\n    throw new Error(\"The following input objects are invalid: \".concat(invalidObjects.join(\", \")));\n  }\n  const objects = resolved.map(object => {\n    if (object.error || !object.data) {\n      throw new Error(\"Failed to fetch object: \".concat(object.error));\n    }\n    const owner = object.data.owner;\n    const initialSharedVersion = owner && typeof owner === \"object\" && \"Shared\" in owner ? owner.Shared.initial_shared_version : null;\n    return {\n      objectId: object.data.objectId,\n      digest: object.data.digest,\n      version: object.data.version,\n      initialSharedVersion\n    };\n  });\n  const objectsById = new Map(dedupedIds.map((id, index) => {\n    return [id, objects[index]];\n  }));\n  for (const [index, input] of transactionData.inputs.entries()) {\n    var _input$UnresolvedObje2, _input$UnresolvedObje5, _input$UnresolvedObje6;\n    if (!input.UnresolvedObject) {\n      continue;\n    }\n    let updated;\n    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n    const object = objectsById.get(id);\n    if ((_input$UnresolvedObje2 = input.UnresolvedObject.initialSharedVersion) !== null && _input$UnresolvedObje2 !== void 0 ? _input$UnresolvedObje2 : object === null || object === void 0 ? void 0 : object.initialSharedVersion) {\n      updated = Inputs.SharedObjectRef({\n        objectId: id,\n        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || (object === null || object === void 0 ? void 0 : object.initialSharedVersion),\n        mutable: isUsedAsMutable(transactionData, index)\n      });\n    } else if (isUsedAsReceiving(transactionData, index)) {\n      var _input$UnresolvedObje3, _input$UnresolvedObje4;\n      updated = Inputs.ReceivingRef({\n        objectId: id,\n        digest: (_input$UnresolvedObje3 = input.UnresolvedObject.digest) !== null && _input$UnresolvedObje3 !== void 0 ? _input$UnresolvedObje3 : object === null || object === void 0 ? void 0 : object.digest,\n        version: (_input$UnresolvedObje4 = input.UnresolvedObject.version) !== null && _input$UnresolvedObje4 !== void 0 ? _input$UnresolvedObje4 : object === null || object === void 0 ? void 0 : object.version\n      });\n    }\n    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated !== null && updated !== void 0 ? updated : Inputs.ObjectRef({\n      objectId: id,\n      digest: (_input$UnresolvedObje5 = input.UnresolvedObject.digest) !== null && _input$UnresolvedObje5 !== void 0 ? _input$UnresolvedObje5 : object === null || object === void 0 ? void 0 : object.digest,\n      version: (_input$UnresolvedObje6 = input.UnresolvedObject.version) !== null && _input$UnresolvedObje6 !== void 0 ? _input$UnresolvedObje6 : object === null || object === void 0 ? void 0 : object.version\n    });\n  }\n}\nasync function normalizeInputs(transactionData, options) {\n  const {\n    inputs,\n    commands\n  } = transactionData;\n  const moveCallsToResolve = [];\n  const moveFunctionsToResolve = /* @__PURE__ */new Set();\n  commands.forEach(command => {\n    if (command.MoveCall) {\n      if (command.MoveCall._argumentTypes) {\n        return;\n      }\n      const inputs2 = command.MoveCall.arguments.map(arg => {\n        if (arg.$kind === \"Input\") {\n          return transactionData.inputs[arg.Input];\n        }\n        return null;\n      });\n      const needsResolution = inputs2.some(input => (input === null || input === void 0 ? void 0 : input.UnresolvedPure) || (input === null || input === void 0 ? void 0 : input.UnresolvedObject));\n      if (needsResolution) {\n        const functionName = \"\".concat(command.MoveCall.package, \"::\").concat(command.MoveCall.module, \"::\").concat(command.MoveCall.function);\n        moveFunctionsToResolve.add(functionName);\n        moveCallsToResolve.push(command.MoveCall);\n      }\n    }\n    switch (command.$kind) {\n      case \"SplitCoins\":\n        command.SplitCoins.amounts.forEach(amount => {\n          normalizeRawArgument(amount, bcs.U64, transactionData);\n        });\n        break;\n      case \"TransferObjects\":\n        normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n        break;\n    }\n  });\n  const moveFunctionParameters = /* @__PURE__ */new Map();\n  if (moveFunctionsToResolve.size > 0) {\n    const client = getClient(options);\n    await Promise.all([...moveFunctionsToResolve].map(async functionName => {\n      const [packageId, moduleId, functionId] = functionName.split(\"::\");\n      const def = await client.getNormalizedMoveFunction({\n        package: packageId,\n        module: moduleId,\n        function: functionId\n      });\n      moveFunctionParameters.set(functionName, def.parameters.map(param => normalizedTypeToMoveTypeSignature(param)));\n    }));\n  }\n  if (moveCallsToResolve.length) {\n    await Promise.all(moveCallsToResolve.map(async moveCall => {\n      const parameters = moveFunctionParameters.get(\"\".concat(moveCall.package, \"::\").concat(moveCall.module, \"::\").concat(moveCall.function));\n      if (!parameters) {\n        return;\n      }\n      const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));\n      const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n      moveCall._argumentTypes = params;\n    }));\n  }\n  commands.forEach(command => {\n    if (!command.MoveCall) {\n      return;\n    }\n    const moveCall = command.MoveCall;\n    const fnName = \"\".concat(moveCall.package, \"::\").concat(moveCall.module, \"::\").concat(moveCall.function);\n    const params = moveCall._argumentTypes;\n    if (!params) {\n      return;\n    }\n    if (params.length !== command.MoveCall.arguments.length) {\n      throw new Error(\"Incorrect number of arguments for \".concat(fnName));\n    }\n    params.forEach((param, i) => {\n      var _input$UnresolvedPure, _input$UnresolvedPure2, _input$UnresolvedObje7;\n      const arg = moveCall.arguments[i];\n      if (arg.$kind !== \"Input\") return;\n      const input = inputs[arg.Input];\n      if (!input.UnresolvedPure && !input.UnresolvedObject) {\n        return;\n      }\n      const inputValue = (_input$UnresolvedPure = (_input$UnresolvedPure2 = input.UnresolvedPure) === null || _input$UnresolvedPure2 === void 0 ? void 0 : _input$UnresolvedPure2.value) !== null && _input$UnresolvedPure !== void 0 ? _input$UnresolvedPure : (_input$UnresolvedObje7 = input.UnresolvedObject) === null || _input$UnresolvedObje7 === void 0 ? void 0 : _input$UnresolvedObje7.objectId;\n      const schema = getPureBcsSchema(param.body);\n      if (schema) {\n        arg.type = \"pure\";\n        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n        return;\n      }\n      if (typeof inputValue !== \"string\") {\n        throw new Error(\"Expect the argument to be an object id string, got \".concat(JSON.stringify(inputValue, null, 2)));\n      }\n      arg.type = \"object\";\n      const unresolvedObject = input.UnresolvedPure ? {\n        $kind: \"UnresolvedObject\",\n        UnresolvedObject: {\n          objectId: inputValue\n        }\n      } : input;\n      inputs[arg.Input] = unresolvedObject;\n    });\n  });\n}\nfunction validate(transactionData) {\n  transactionData.inputs.forEach((input, index) => {\n    if (input.$kind !== \"Object\" && input.$kind !== \"Pure\") {\n      throw new Error(\"Input at index \".concat(index, \" has not been resolved.  Expected a Pure or Object input, but found \").concat(JSON.stringify(input)));\n    }\n  });\n}\nfunction normalizeRawArgument(arg, schema, transactionData) {\n  if (arg.$kind !== \"Input\") {\n    return;\n  }\n  const input = transactionData.inputs[arg.Input];\n  if (input.$kind !== \"UnresolvedPure\") {\n    return;\n  }\n  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\nfunction isUsedAsMutable(transactionData, index) {\n  let usedAsMutable = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== \"&\" || usedAsMutable;\n    }\n    if (tx.$kind === \"MakeMoveVec\" || tx.$kind === \"MergeCoins\" || tx.$kind === \"SplitCoins\") {\n      usedAsMutable = true;\n    }\n  });\n  return usedAsMutable;\n}\nfunction isUsedAsReceiving(transactionData, index) {\n  let usedAsReceiving = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n    }\n  });\n  return usedAsReceiving;\n}\nfunction isReceivingType(type) {\n  if (typeof type.body !== \"object\" || !(\"datatype\" in type.body)) {\n    return false;\n  }\n  return type.body.datatype.package === \"0x2\" && type.body.datatype.module === \"transfer\" && type.body.datatype.type === \"Receiving\";\n}\nfunction getClient(options) {\n  if (!options.client) {\n    throw new Error(\"No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.\");\n  }\n  return options.client;\n}\nfunction chunk(arr, size) {\n  return Array.from({\n    length: Math.ceil(arr.length / size)\n  }, (_, i) => arr.slice(i * size, i * size + size));\n}\nexport { getClient, resolveTransactionData };\n//# sourceMappingURL=json-rpc-resolver.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}