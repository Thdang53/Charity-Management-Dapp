{"ast":null,"code":"import _objectSpread from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _cache, _url, _pageSize, _overrides, _MvrClient_instances, mvrPackageDataLoader_get, mvrTypeDataLoader_get, resolvePackages_fn, resolveTypes_fn, fetch_fn;\nimport { chunk, DataLoader } from \"@mysten/utils\";\nimport { isValidNamedPackage, isValidNamedType } from \"../utils/move-registry.js\";\nimport { isValidSuiAddress, normalizeStructTag, normalizeSuiAddress, parseStructTag } from \"../utils/sui-types.js\";\nimport { PACKAGE_VERSION } from \"../version.js\";\nconst NAME_SEPARATOR = \"/\";\nconst MVR_API_HEADER = {\n  \"Mvr-Source\": \"@mysten/sui@\".concat(PACKAGE_VERSION)\n};\nclass MvrClient {\n  constructor(_ref) {\n    let {\n      cache,\n      url,\n      pageSize = 50,\n      overrides\n    } = _ref;\n    __privateAdd(this, _MvrClient_instances);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _url);\n    __privateAdd(this, _pageSize);\n    __privateAdd(this, _overrides);\n    __privateSet(this, _cache, cache);\n    __privateSet(this, _url, url);\n    __privateSet(this, _pageSize, pageSize);\n    __privateSet(this, _overrides, {\n      packages: overrides === null || overrides === void 0 ? void 0 : overrides.packages,\n      types: overrides === null || overrides === void 0 ? void 0 : overrides.types\n    });\n    validateOverrides(__privateGet(this, _overrides));\n  }\n  async resolvePackage(_ref2) {\n    let {\n      package: name\n    } = _ref2;\n    if (!hasMvrName(name)) {\n      return {\n        package: name\n      };\n    }\n    const resolved = await __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).load(name);\n    return {\n      package: resolved\n    };\n  }\n  async resolveType(_ref3) {\n    let {\n      type\n    } = _ref3;\n    if (!hasMvrName(type)) {\n      return {\n        type\n      };\n    }\n    const mvrTypes = [...extractMvrTypes(type)];\n    const resolvedTypes = await __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(mvrTypes);\n    const typeMap = {};\n    for (let i = 0; i < mvrTypes.length; i++) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[mvrTypes[i]] = resolvedType;\n    }\n    return {\n      type: replaceMvrNames(type, typeMap)\n    };\n  }\n  async resolve(_ref4) {\n    var _privateGet;\n    let {\n      types = [],\n      packages = []\n    } = _ref4;\n    const mvrTypes = /* @__PURE__ */new Set();\n    for (const type of types !== null && types !== void 0 ? types : []) {\n      extractMvrTypes(type, mvrTypes);\n    }\n    const typesArray = [...mvrTypes];\n    const [resolvedTypes, resolvedPackages] = await Promise.all([typesArray.length > 0 ? __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(typesArray) : [], packages.length > 0 ? __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).loadMany(packages) : []]);\n    const typeMap = _objectSpread({}, (_privateGet = __privateGet(this, _overrides)) === null || _privateGet === void 0 ? void 0 : _privateGet.types);\n    for (const [i, type] of typesArray.entries()) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[type] = resolvedType;\n    }\n    const replacedTypes = {};\n    for (const type of types !== null && types !== void 0 ? types : []) {\n      const resolvedType = replaceMvrNames(type, typeMap);\n      replacedTypes[type] = {\n        type: resolvedType\n      };\n    }\n    const replacedPackages = {};\n    for (const [i, pkg] of (packages !== null && packages !== void 0 ? packages : []).entries()) {\n      var _privateGet$packages, _privateGet2;\n      const resolvedPkg = (_privateGet$packages = (_privateGet2 = __privateGet(this, _overrides)) === null || _privateGet2 === void 0 || (_privateGet2 = _privateGet2.packages) === null || _privateGet2 === void 0 ? void 0 : _privateGet2[pkg]) !== null && _privateGet$packages !== void 0 ? _privateGet$packages : resolvedPackages[i];\n      if (resolvedPkg instanceof Error) {\n        throw resolvedPkg;\n      }\n      replacedPackages[pkg] = {\n        package: resolvedPkg\n      };\n    }\n    return {\n      types: replacedTypes,\n      packages: replacedPackages\n    };\n  }\n}\n_cache = new WeakMap();\n_url = new WeakMap();\n_pageSize = new WeakMap();\n_overrides = new WeakMap();\n_MvrClient_instances = new WeakSet();\nmvrPackageDataLoader_get = function () {\n  var _privateGet3;\n  return __privateGet(this, _cache).readSync([\"#mvrPackageDataLoader\", (_privateGet3 = __privateGet(this, _url)) !== null && _privateGet3 !== void 0 ? _privateGet3 : \"\"], () => {\n    var _privateGet4;\n    const loader = new DataLoader(async packages => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(\"MVR Api URL is not set for the current client (resolving \".concat(packages.join(\", \"), \")\"));\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolvePackages_fn).call(this, packages);\n      return packages.map(pkg => {\n        var _resolved$pkg;\n        return (_resolved$pkg = resolved[pkg]) !== null && _resolved$pkg !== void 0 ? _resolved$pkg : new Error(\"Failed to resolve package: \".concat(pkg));\n      });\n    });\n    const overrides = (_privateGet4 = __privateGet(this, _overrides)) === null || _privateGet4 === void 0 ? void 0 : _privateGet4.packages;\n    if (overrides) {\n      for (const [pkg, id] of Object.entries(overrides)) {\n        loader.prime(pkg, id);\n      }\n    }\n    return loader;\n  });\n};\nmvrTypeDataLoader_get = function () {\n  var _privateGet5;\n  return __privateGet(this, _cache).readSync([\"#mvrTypeDataLoader\", (_privateGet5 = __privateGet(this, _url)) !== null && _privateGet5 !== void 0 ? _privateGet5 : \"\"], () => {\n    var _privateGet6;\n    const loader = new DataLoader(async types => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(\"MVR Api URL is not set for the current client (resolving \".concat(types.join(\", \"), \")\"));\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolveTypes_fn).call(this, types);\n      return types.map(type => {\n        var _resolved$type;\n        return (_resolved$type = resolved[type]) !== null && _resolved$type !== void 0 ? _resolved$type : new Error(\"Failed to resolve type: \".concat(type));\n      });\n    });\n    const overrides = (_privateGet6 = __privateGet(this, _overrides)) === null || _privateGet6 === void 0 ? void 0 : _privateGet6.types;\n    if (overrides) {\n      for (const [type, id] of Object.entries(overrides)) {\n        loader.prime(type, id);\n      }\n    }\n    return loader;\n  });\n};\nresolvePackages_fn = async function (packages) {\n  if (packages.length === 0) return {};\n  const batches = chunk(packages, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(batches.map(async batch => {\n    const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/resolution/bulk\", {\n      names: batch\n    });\n    if (!(data !== null && data !== void 0 && data.resolution)) return;\n    for (const pkg of Object.keys(data === null || data === void 0 ? void 0 : data.resolution)) {\n      var _data$resolution$pkg;\n      const pkgData = (_data$resolution$pkg = data.resolution[pkg]) === null || _data$resolution$pkg === void 0 ? void 0 : _data$resolution$pkg.package_id;\n      if (!pkgData) continue;\n      results[pkg] = pkgData;\n    }\n  }));\n  return results;\n};\nresolveTypes_fn = async function (types) {\n  if (types.length === 0) return {};\n  const batches = chunk(types, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(batches.map(async batch => {\n    const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/struct-definition/bulk\", {\n      types: batch\n    });\n    if (!(data !== null && data !== void 0 && data.resolution)) return;\n    for (const type of Object.keys(data === null || data === void 0 ? void 0 : data.resolution)) {\n      var _data$resolution$type;\n      const typeData = (_data$resolution$type = data.resolution[type]) === null || _data$resolution$type === void 0 ? void 0 : _data$resolution$type.type_tag;\n      if (!typeData) continue;\n      results[type] = typeData;\n    }\n  }));\n  return results;\n};\nfetch_fn = async function (url, body) {\n  if (!__privateGet(this, _url)) {\n    throw new Error(\"MVR Api URL is not set for the current client\");\n  }\n  const response = await fetch(\"\".concat(__privateGet(this, _url)).concat(url), {\n    method: \"POST\",\n    headers: _objectSpread({\n      \"Content-Type\": \"application/json\"\n    }, MVR_API_HEADER),\n    body: JSON.stringify(body)\n  });\n  if (!response.ok) {\n    const errorBody = await response.json().catch(() => ({}));\n    throw new Error(\"Failed to resolve types: \".concat(errorBody === null || errorBody === void 0 ? void 0 : errorBody.message));\n  }\n  return response.json();\n};\nfunction validateOverrides(overrides) {\n  if (overrides !== null && overrides !== void 0 && overrides.packages) {\n    for (const [pkg, id] of Object.entries(overrides.packages)) {\n      if (!isValidNamedPackage(pkg)) {\n        throw new Error(\"Invalid package name: \".concat(pkg));\n      }\n      if (!isValidSuiAddress(normalizeSuiAddress(id))) {\n        throw new Error(\"Invalid package ID: \".concat(id));\n      }\n    }\n  }\n  if (overrides !== null && overrides !== void 0 && overrides.types) {\n    for (const [type, val] of Object.entries(overrides.types)) {\n      if (parseStructTag(type).typeParams.length > 0) {\n        throw new Error(\"Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.\");\n      }\n      const parsedValue = parseStructTag(val);\n      if (!isValidSuiAddress(parsedValue.address)) {\n        throw new Error(\"Invalid type: \".concat(val));\n      }\n    }\n  }\n}\nfunction extractMvrTypes(type) {\n  let types = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Set();\n  if (typeof type === \"string\" && !hasMvrName(type)) return types;\n  const tag = isStructTag(type) ? type : parseStructTag(type);\n  if (hasMvrName(tag.address)) types.add(\"\".concat(tag.address, \"::\").concat(tag.module, \"::\").concat(tag.name));\n  for (const param of tag.typeParams) {\n    extractMvrTypes(param, types);\n  }\n  return types;\n}\nfunction replaceMvrNames(tag, typeCache) {\n  const type = isStructTag(tag) ? tag : parseStructTag(tag);\n  const typeTag = \"\".concat(type.address, \"::\").concat(type.module, \"::\").concat(type.name);\n  const cacheHit = typeCache[typeTag];\n  return normalizeStructTag(_objectSpread(_objectSpread({}, type), {}, {\n    address: cacheHit ? cacheHit.split(\"::\")[0] : type.address,\n    typeParams: type.typeParams.map(param => replaceMvrNames(param, typeCache))\n  }));\n}\nfunction hasMvrName(nameOrType) {\n  return nameOrType.includes(NAME_SEPARATOR) || nameOrType.includes(\"@\") || nameOrType.includes(\".sui\");\n}\nfunction isStructTag(type) {\n  return typeof type === \"object\" && \"address\" in type && \"module\" in type && \"name\" in type && \"typeParams\" in type;\n}\nfunction findNamesInTransaction(builder) {\n  var _moveCall$typeArgumen;\n  const packages = /* @__PURE__ */new Set();\n  const types = /* @__PURE__ */new Set();\n  for (const command of builder.commands) {\n    switch (command.$kind) {\n      case \"MakeMoveVec\":\n        if (command.MakeMoveVec.type) {\n          getNamesFromTypeList([command.MakeMoveVec.type]).forEach(type => {\n            types.add(type);\n          });\n        }\n        break;\n      case \"MoveCall\":\n        const moveCall = command.MoveCall;\n        const pkg = moveCall.package.split(\"::\")[0];\n        if (hasMvrName(pkg)) {\n          if (!isValidNamedPackage(pkg)) throw new Error(\"Invalid package name: \".concat(pkg));\n          packages.add(pkg);\n        }\n        getNamesFromTypeList((_moveCall$typeArgumen = moveCall.typeArguments) !== null && _moveCall$typeArgumen !== void 0 ? _moveCall$typeArgumen : []).forEach(type => {\n          types.add(type);\n        });\n        break;\n      default:\n        break;\n    }\n  }\n  return {\n    packages: [...packages],\n    types: [...types]\n  };\n}\nfunction replaceNames(builder, resolved) {\n  for (const command of builder.commands) {\n    var _command$MakeMoveVec;\n    if ((_command$MakeMoveVec = command.MakeMoveVec) !== null && _command$MakeMoveVec !== void 0 && _command$MakeMoveVec.type) {\n      if (!hasMvrName(command.MakeMoveVec.type)) continue;\n      if (!resolved.types[command.MakeMoveVec.type]) throw new Error(\"No resolution found for type: \".concat(command.MakeMoveVec.type));\n      command.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n    }\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const nameParts = tx.package.split(\"::\");\n    const name = nameParts[0];\n    if (hasMvrName(name) && !resolved.packages[name]) throw new Error(\"No address found for package: \".concat(name));\n    if (hasMvrName(name)) {\n      nameParts[0] = resolved.packages[name].package;\n      tx.package = nameParts.join(\"::\");\n    }\n    const types = tx.typeArguments;\n    if (!types) continue;\n    for (let i = 0; i < types.length; i++) {\n      if (!hasMvrName(types[i])) continue;\n      if (!resolved.types[types[i]]) throw new Error(\"No resolution found for type: \".concat(types[i]));\n      types[i] = resolved.types[types[i]].type;\n    }\n    tx.typeArguments = types;\n  }\n}\nfunction getNamesFromTypeList(types) {\n  const names = /* @__PURE__ */new Set();\n  for (const type of types) {\n    if (hasMvrName(type)) {\n      if (!isValidNamedType(type)) throw new Error(\"Invalid type with names: \".concat(type));\n      names.add(type);\n    }\n  }\n  return names;\n}\nexport { MvrClient, extractMvrTypes, findNamesInTransaction, hasMvrName, replaceNames };\n//# sourceMappingURL=mvr.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}