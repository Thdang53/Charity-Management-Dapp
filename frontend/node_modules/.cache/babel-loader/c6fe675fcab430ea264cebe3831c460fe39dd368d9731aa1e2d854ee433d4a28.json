{"ast":null,"code":"import _objectSpread from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classPrivateMethodInitSpec from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _assertClassBrand from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _defineProperty from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nconst _excluded = [\"context\", \"forceRefresh\"];\n/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = typeof process === 'object' && !!process ? process : {};\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n  typeof PROCESS.emitWarning === 'function' ? PROCESS.emitWarning(msg, type, code, fn) : console.error(\"[\".concat(code, \"] \").concat(type, \": \").concat(msg));\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  var _PROCESS$env;\n  //@ts-ignore\n  AS = class AbortSignal {\n    constructor() {\n      _defineProperty(this, \"onabort\", void 0);\n      _defineProperty(this, \"_onabort\", []);\n      _defineProperty(this, \"reason\", void 0);\n      _defineProperty(this, \"aborted\", false);\n    }\n    addEventListener(_, fn) {\n      this._onabort.push(fn);\n    }\n  };\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      _defineProperty(this, \"signal\", new AS());\n      warnACPolyfill();\n    }\n    abort(reason) {\n      var _this$signal$onabort, _this$signal;\n      if (this.signal.aborted) return;\n      //@ts-ignore\n      this.signal.reason = reason;\n      //@ts-ignore\n      this.signal.aborted = true;\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason);\n      }\n      (_this$signal$onabort = (_this$signal = this.signal).onabort) === null || _this$signal$onabort === void 0 || _this$signal$onabort.call(_this$signal, reason);\n    }\n  };\n  let printACPolyfillWarning = ((_PROCESS$env = PROCESS.env) === null || _PROCESS$env === void 0 ? void 0 : _PROCESS$env.LRU_CACHE_IGNORE_AC_WARNING) !== '1';\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return;\n    printACPolyfillWarning = false;\n    emitWarning('AbortController is not defined. If using lru-cache in ' + 'node 14, load an AbortController polyfill from the ' + '`node-abort-controller` package. A minimal polyfill is ' + 'provided for use by LRUCache.fetch(), but it should not be ' + 'relied upon in other contexts (eg, passing it to other APIs that ' + 'use AbortController/AbortSignal might have undesirable effects). ' + 'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n  };\n}\n/* c8 ignore stop */\nconst shouldWarn = code => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = max => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size);\n    this.fill(0);\n  }\n}\nclass Stack {\n  static create(max) {\n    const HeapCls = getUintArray(max);\n    if (!HeapCls) return [];\n    _constructing._ = true;\n    const s = new Stack(max, HeapCls);\n    _constructing._ = false;\n    return s;\n  }\n  constructor(max, HeapCls) {\n    _defineProperty(this, \"heap\", void 0);\n    _defineProperty(this, \"length\", void 0);\n    /* c8 ignore start */\n    if (!_constructing._) {\n      throw new TypeError('instantiate Stack using Stack.create(n)');\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max);\n    this.length = 0;\n  }\n  push(n) {\n    this.heap[this.length++] = n;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\n// private constructor\nvar _constructing = {\n  _: false\n};\nvar _max = /*#__PURE__*/new WeakMap();\nvar _maxSize = /*#__PURE__*/new WeakMap();\nvar _dispose = /*#__PURE__*/new WeakMap();\nvar _disposeAfter = /*#__PURE__*/new WeakMap();\nvar _fetchMethod = /*#__PURE__*/new WeakMap();\nvar _memoMethod = /*#__PURE__*/new WeakMap();\nvar _size = /*#__PURE__*/new WeakMap();\nvar _calculatedSize = /*#__PURE__*/new WeakMap();\nvar _keyMap = /*#__PURE__*/new WeakMap();\nvar _keyList = /*#__PURE__*/new WeakMap();\nvar _valList = /*#__PURE__*/new WeakMap();\nvar _next = /*#__PURE__*/new WeakMap();\nvar _prev = /*#__PURE__*/new WeakMap();\nvar _head = /*#__PURE__*/new WeakMap();\nvar _tail = /*#__PURE__*/new WeakMap();\nvar _free = /*#__PURE__*/new WeakMap();\nvar _disposed = /*#__PURE__*/new WeakMap();\nvar _sizes = /*#__PURE__*/new WeakMap();\nvar _starts = /*#__PURE__*/new WeakMap();\nvar _ttls = /*#__PURE__*/new WeakMap();\nvar _hasDispose = /*#__PURE__*/new WeakMap();\nvar _hasFetchMethod = /*#__PURE__*/new WeakMap();\nvar _hasDisposeAfter = /*#__PURE__*/new WeakMap();\nvar _LRUCache_brand = /*#__PURE__*/new WeakSet();\nvar _updateItemAge = /*#__PURE__*/new WeakMap();\nvar _statusTTL = /*#__PURE__*/new WeakMap();\nvar _setItemTTL = /*#__PURE__*/new WeakMap();\nvar _isStale = /*#__PURE__*/new WeakMap();\nvar _removeItemSize = /*#__PURE__*/new WeakMap();\nvar _addItemSize = /*#__PURE__*/new WeakMap();\nvar _requireSize = /*#__PURE__*/new WeakMap();\nexport class LRUCache {\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals(c) {\n    return {\n      // properties\n      starts: _classPrivateFieldGet(_starts, c),\n      ttls: _classPrivateFieldGet(_ttls, c),\n      sizes: _classPrivateFieldGet(_sizes, c),\n      keyMap: _classPrivateFieldGet(_keyMap, c),\n      keyList: _classPrivateFieldGet(_keyList, c),\n      valList: _classPrivateFieldGet(_valList, c),\n      next: _classPrivateFieldGet(_next, c),\n      prev: _classPrivateFieldGet(_prev, c),\n      get head() {\n        return _classPrivateFieldGet(_head, c);\n      },\n      get tail() {\n        return _classPrivateFieldGet(_tail, c);\n      },\n      free: _classPrivateFieldGet(_free, c),\n      // methods\n      isBackgroundFetch: p => _assertClassBrand(_LRUCache_brand, c, _isBackgroundFetch).call(c, p),\n      backgroundFetch: (k, index, options, context) => _assertClassBrand(_LRUCache_brand, c, _backgroundFetch).call(c, k, index, options, context),\n      moveToTail: index => _assertClassBrand(_LRUCache_brand, c, _moveToTail).call(c, index),\n      indexes: options => _assertClassBrand(_LRUCache_brand, c, _indexes).call(c, options),\n      rindexes: options => _assertClassBrand(_LRUCache_brand, c, _rindexes).call(c, options),\n      isStale: index => _classPrivateFieldGet(_isStale, c).call(c, index)\n    };\n  }\n  // Protected read-only members\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max() {\n    return _classPrivateFieldGet(_max, this);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize() {\n    return _classPrivateFieldGet(_maxSize, this);\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize() {\n    return _classPrivateFieldGet(_calculatedSize, this);\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size() {\n    return _classPrivateFieldGet(_size, this);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod() {\n    return _classPrivateFieldGet(_fetchMethod, this);\n  }\n  get memoMethod() {\n    return _classPrivateFieldGet(_memoMethod, this);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return _classPrivateFieldGet(_dispose, this);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return _classPrivateFieldGet(_disposeAfter, this);\n  }\n  constructor(_options) {\n    _classPrivateMethodInitSpec(this, _LRUCache_brand);\n    // options that cannot be changed without disaster\n    _classPrivateFieldInitSpec(this, _max, void 0);\n    _classPrivateFieldInitSpec(this, _maxSize, void 0);\n    _classPrivateFieldInitSpec(this, _dispose, void 0);\n    _classPrivateFieldInitSpec(this, _disposeAfter, void 0);\n    _classPrivateFieldInitSpec(this, _fetchMethod, void 0);\n    _classPrivateFieldInitSpec(this, _memoMethod, void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    _defineProperty(this, \"ttl\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    _defineProperty(this, \"ttlResolution\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    _defineProperty(this, \"ttlAutopurge\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    _defineProperty(this, \"updateAgeOnGet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    _defineProperty(this, \"updateAgeOnHas\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    _defineProperty(this, \"allowStale\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    _defineProperty(this, \"noDisposeOnSet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    _defineProperty(this, \"noUpdateTTL\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    _defineProperty(this, \"maxEntrySize\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    _defineProperty(this, \"sizeCalculation\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    _defineProperty(this, \"noDeleteOnFetchRejection\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    _defineProperty(this, \"noDeleteOnStaleGet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    _defineProperty(this, \"allowStaleOnFetchAbort\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    _defineProperty(this, \"allowStaleOnFetchRejection\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    _defineProperty(this, \"ignoreFetchAbort\", void 0);\n    // computed properties\n    _classPrivateFieldInitSpec(this, _size, void 0);\n    _classPrivateFieldInitSpec(this, _calculatedSize, void 0);\n    _classPrivateFieldInitSpec(this, _keyMap, void 0);\n    _classPrivateFieldInitSpec(this, _keyList, void 0);\n    _classPrivateFieldInitSpec(this, _valList, void 0);\n    _classPrivateFieldInitSpec(this, _next, void 0);\n    _classPrivateFieldInitSpec(this, _prev, void 0);\n    _classPrivateFieldInitSpec(this, _head, void 0);\n    _classPrivateFieldInitSpec(this, _tail, void 0);\n    _classPrivateFieldInitSpec(this, _free, void 0);\n    _classPrivateFieldInitSpec(this, _disposed, void 0);\n    _classPrivateFieldInitSpec(this, _sizes, void 0);\n    _classPrivateFieldInitSpec(this, _starts, void 0);\n    _classPrivateFieldInitSpec(this, _ttls, void 0);\n    _classPrivateFieldInitSpec(this, _hasDispose, void 0);\n    _classPrivateFieldInitSpec(this, _hasFetchMethod, void 0);\n    _classPrivateFieldInitSpec(this, _hasDisposeAfter, void 0);\n    // conditionally set private methods related to TTL\n    _classPrivateFieldInitSpec(this, _updateItemAge, () => {});\n    _classPrivateFieldInitSpec(this, _statusTTL, () => {});\n    _classPrivateFieldInitSpec(this, _setItemTTL, () => {});\n    /* c8 ignore stop */\n    _classPrivateFieldInitSpec(this, _isStale, () => false);\n    _classPrivateFieldInitSpec(this, _removeItemSize, _i => {});\n    _classPrivateFieldInitSpec(this, _addItemSize, (_i, _s, _st) => {});\n    _classPrivateFieldInitSpec(this, _requireSize, (_k, _v, size, sizeCalculation) => {\n      if (size || sizeCalculation) {\n        throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n      }\n      return 0;\n    });\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    _defineProperty(this, Symbol.toStringTag, 'LRUCache');\n    const {\n      max = 0,\n      ttl: _ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale: _allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize: _maxSize2 = 0,\n      maxEntrySize = 0,\n      sizeCalculation: _sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort\n    } = _options;\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer');\n    }\n    const UintArray = max ? getUintArray(max) : Array;\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max);\n    }\n    _classPrivateFieldSet(_max, this, max);\n    _classPrivateFieldSet(_maxSize, this, _maxSize2);\n    this.maxEntrySize = maxEntrySize || _classPrivateFieldGet(_maxSize, this);\n    this.sizeCalculation = _sizeCalculation;\n    if (this.sizeCalculation) {\n      if (!_classPrivateFieldGet(_maxSize, this) && !this.maxEntrySize) {\n        throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function');\n      }\n    }\n    if (memoMethod !== undefined && typeof memoMethod !== 'function') {\n      throw new TypeError('memoMethod must be a function if defined');\n    }\n    _classPrivateFieldSet(_memoMethod, this, memoMethod);\n    if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified');\n    }\n    _classPrivateFieldSet(_fetchMethod, this, fetchMethod);\n    _classPrivateFieldSet(_hasFetchMethod, this, !!fetchMethod);\n    _classPrivateFieldSet(_keyMap, this, new Map());\n    _classPrivateFieldSet(_keyList, this, new Array(max).fill(undefined));\n    _classPrivateFieldSet(_valList, this, new Array(max).fill(undefined));\n    _classPrivateFieldSet(_next, this, new UintArray(max));\n    _classPrivateFieldSet(_prev, this, new UintArray(max));\n    _classPrivateFieldSet(_head, this, 0);\n    _classPrivateFieldSet(_tail, this, 0);\n    _classPrivateFieldSet(_free, this, Stack.create(max));\n    _classPrivateFieldSet(_size, this, 0);\n    _classPrivateFieldSet(_calculatedSize, this, 0);\n    if (typeof dispose === 'function') {\n      _classPrivateFieldSet(_dispose, this, dispose);\n    }\n    if (typeof disposeAfter === 'function') {\n      _classPrivateFieldSet(_disposeAfter, this, disposeAfter);\n      _classPrivateFieldSet(_disposed, this, []);\n    } else {\n      _classPrivateFieldSet(_disposeAfter, this, undefined);\n      _classPrivateFieldSet(_disposed, this, undefined);\n    }\n    _classPrivateFieldSet(_hasDispose, this, !!_classPrivateFieldGet(_dispose, this));\n    _classPrivateFieldSet(_hasDisposeAfter, this, !!_classPrivateFieldGet(_disposeAfter, this));\n    this.noDisposeOnSet = !!noDisposeOnSet;\n    this.noUpdateTTL = !!noUpdateTTL;\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n    this.ignoreFetchAbort = !!ignoreFetchAbort;\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (_classPrivateFieldGet(_maxSize, this) !== 0) {\n        if (!isPosInt(_classPrivateFieldGet(_maxSize, this))) {\n          throw new TypeError('maxSize must be a positive integer if specified');\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError('maxEntrySize must be a positive integer if specified');\n      }\n      _assertClassBrand(_LRUCache_brand, this, _initializeSizeTracking).call(this);\n    }\n    this.allowStale = !!_allowStale;\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n    this.updateAgeOnGet = !!updateAgeOnGet;\n    this.updateAgeOnHas = !!updateAgeOnHas;\n    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n    this.ttlAutopurge = !!ttlAutopurge;\n    this.ttl = _ttl || 0;\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified');\n      }\n      _assertClassBrand(_LRUCache_brand, this, _initializeTTLTracking).call(this);\n    }\n    // do not allow completely unbounded caches\n    if (_classPrivateFieldGet(_max, this) === 0 && this.ttl === 0 && _classPrivateFieldGet(_maxSize, this) === 0) {\n      throw new TypeError('At least one of max, maxSize, or ttl is required');\n    }\n    if (!this.ttlAutopurge && !_classPrivateFieldGet(_max, this) && !_classPrivateFieldGet(_maxSize, this)) {\n      const code = 'LRU_CACHE_UNBOUNDED';\n      if (shouldWarn(code)) {\n        warned.add(code);\n        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n      }\n    }\n  }\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key) {\n    return _classPrivateFieldGet(_keyMap, this).has(key) ? Infinity : 0;\n  }\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _indexes).call(this)) {\n      if (_classPrivateFieldGet(_valList, this)[i] !== undefined && _classPrivateFieldGet(_keyList, this)[i] !== undefined && !_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, _classPrivateFieldGet(_valList, this)[i])) {\n        yield [_classPrivateFieldGet(_keyList, this)[i], _classPrivateFieldGet(_valList, this)[i]];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _rindexes).call(this)) {\n      if (_classPrivateFieldGet(_valList, this)[i] !== undefined && _classPrivateFieldGet(_keyList, this)[i] !== undefined && !_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, _classPrivateFieldGet(_valList, this)[i])) {\n        yield [_classPrivateFieldGet(_keyList, this)[i], _classPrivateFieldGet(_valList, this)[i]];\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _indexes).call(this)) {\n      const k = _classPrivateFieldGet(_keyList, this)[i];\n      if (k !== undefined && !_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, _classPrivateFieldGet(_valList, this)[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _rindexes).call(this)) {\n      const k = _classPrivateFieldGet(_keyList, this)[i];\n      if (k !== undefined && !_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, _classPrivateFieldGet(_valList, this)[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _indexes).call(this)) {\n      const v = _classPrivateFieldGet(_valList, this)[i];\n      if (v !== undefined && !_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, _classPrivateFieldGet(_valList, this)[i])) {\n        yield _classPrivateFieldGet(_valList, this)[i];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _rindexes).call(this)) {\n      const v = _classPrivateFieldGet(_valList, this)[i];\n      if (v !== undefined && !_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, _classPrivateFieldGet(_valList, this)[i])) {\n        yield _classPrivateFieldGet(_valList, this)[i];\n      }\n    }\n  }\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(fn) {\n    let getOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _indexes).call(this)) {\n      const v = _classPrivateFieldGet(_valList, this)[i];\n      const value = _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      if (fn(value, _classPrivateFieldGet(_keyList, this)[i], this)) {\n        return this.get(_classPrivateFieldGet(_keyList, this)[i], getOptions);\n      }\n    }\n  }\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(fn) {\n    let thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _indexes).call(this)) {\n      const v = _classPrivateFieldGet(_valList, this)[i];\n      const value = _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, _classPrivateFieldGet(_keyList, this)[i], this);\n    }\n  }\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(fn) {\n    let thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _rindexes).call(this)) {\n      const v = _classPrivateFieldGet(_valList, this)[i];\n      const value = _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, _classPrivateFieldGet(_keyList, this)[i], this);\n    }\n  }\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false;\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _rindexes).call(this, {\n      allowStale: true\n    })) {\n      if (_classPrivateFieldGet(_isStale, this).call(this, i)) {\n        _assertClassBrand(_LRUCache_brand, this, _delete).call(this, _classPrivateFieldGet(_keyList, this)[i], 'expire');\n        deleted = true;\n      }\n    }\n    return deleted;\n  }\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key) {\n    const i = _classPrivateFieldGet(_keyMap, this).get(key);\n    if (i === undefined) return undefined;\n    const v = _classPrivateFieldGet(_valList, this)[i];\n    const value = _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;\n    if (value === undefined) return undefined;\n    const entry = {\n      value\n    };\n    if (_classPrivateFieldGet(_ttls, this) && _classPrivateFieldGet(_starts, this)) {\n      const ttl = _classPrivateFieldGet(_ttls, this)[i];\n      const start = _classPrivateFieldGet(_starts, this)[i];\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start);\n        entry.ttl = remain;\n        entry.start = Date.now();\n      }\n    }\n    if (_classPrivateFieldGet(_sizes, this)) {\n      entry.size = _classPrivateFieldGet(_sizes, this)[i];\n    }\n    return entry;\n  }\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr = [];\n    for (const i of _assertClassBrand(_LRUCache_brand, this, _indexes).call(this, {\n      allowStale: true\n    })) {\n      const key = _classPrivateFieldGet(_keyList, this)[i];\n      const v = _classPrivateFieldGet(_valList, this)[i];\n      const value = _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined || key === undefined) continue;\n      const entry = {\n        value\n      };\n      if (_classPrivateFieldGet(_ttls, this) && _classPrivateFieldGet(_starts, this)) {\n        entry.ttl = _classPrivateFieldGet(_ttls, this)[i];\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - _classPrivateFieldGet(_starts, this)[i];\n        entry.start = Math.floor(Date.now() - age);\n      }\n      if (_classPrivateFieldGet(_sizes, this)) {\n        entry.size = _classPrivateFieldGet(_sizes, this)[i];\n      }\n      arr.unshift([key, entry]);\n    }\n    return arr;\n  }\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr) {\n    this.clear();\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start;\n        entry.start = perf.now() - age;\n      }\n      this.set(key, entry.value, entry);\n    }\n  }\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(k, v) {\n    let setOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (v === undefined) {\n      this.delete(k);\n      return this;\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status\n    } = setOptions;\n    let {\n      noUpdateTTL = this.noUpdateTTL\n    } = setOptions;\n    const size = _classPrivateFieldGet(_requireSize, this).call(this, k, v, setOptions.size || 0, sizeCalculation);\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss';\n        status.maxEntrySizeExceeded = true;\n      }\n      // have to delete, in case something is there already.\n      _assertClassBrand(_LRUCache_brand, this, _delete).call(this, k, 'set');\n      return this;\n    }\n    let index = _classPrivateFieldGet(_size, this) === 0 ? undefined : _classPrivateFieldGet(_keyMap, this).get(k);\n    if (index === undefined) {\n      var _this$size, _this$size2;\n      // addition\n      index = _classPrivateFieldGet(_size, this) === 0 ? _classPrivateFieldGet(_tail, this) : _classPrivateFieldGet(_free, this).length !== 0 ? _classPrivateFieldGet(_free, this).pop() : _classPrivateFieldGet(_size, this) === _classPrivateFieldGet(_max, this) ? _assertClassBrand(_LRUCache_brand, this, _evict).call(this, false) : _classPrivateFieldGet(_size, this);\n      _classPrivateFieldGet(_keyList, this)[index] = k;\n      _classPrivateFieldGet(_valList, this)[index] = v;\n      _classPrivateFieldGet(_keyMap, this).set(k, index);\n      _classPrivateFieldGet(_next, this)[_classPrivateFieldGet(_tail, this)] = index;\n      _classPrivateFieldGet(_prev, this)[index] = _classPrivateFieldGet(_tail, this);\n      _classPrivateFieldSet(_tail, this, index);\n      _classPrivateFieldSet(_size, this, (_this$size = _classPrivateFieldGet(_size, this), _this$size2 = _this$size++, _this$size)), _this$size2;\n      _classPrivateFieldGet(_addItemSize, this).call(this, index, size, status);\n      if (status) status.set = 'add';\n      noUpdateTTL = false;\n    } else {\n      // update\n      _assertClassBrand(_LRUCache_brand, this, _moveToTail).call(this, index);\n      const oldVal = _classPrivateFieldGet(_valList, this)[index];\n      if (v !== oldVal) {\n        if (_classPrivateFieldGet(_hasFetchMethod, this) && _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'));\n          const {\n            __staleWhileFetching: s\n          } = oldVal;\n          if (s !== undefined && !noDisposeOnSet) {\n            if (_classPrivateFieldGet(_hasDispose, this)) {\n              var _classPrivateFieldGet2;\n              (_classPrivateFieldGet2 = _classPrivateFieldGet(_dispose, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this, s, k, 'set');\n            }\n            if (_classPrivateFieldGet(_hasDisposeAfter, this)) {\n              var _classPrivateFieldGet3;\n              (_classPrivateFieldGet3 = _classPrivateFieldGet(_disposed, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.push([s, k, 'set']);\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (_classPrivateFieldGet(_hasDispose, this)) {\n            var _classPrivateFieldGet4;\n            (_classPrivateFieldGet4 = _classPrivateFieldGet(_dispose, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.call(this, oldVal, k, 'set');\n          }\n          if (_classPrivateFieldGet(_hasDisposeAfter, this)) {\n            var _classPrivateFieldGet5;\n            (_classPrivateFieldGet5 = _classPrivateFieldGet(_disposed, this)) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.push([oldVal, k, 'set']);\n          }\n        }\n        _classPrivateFieldGet(_removeItemSize, this).call(this, index);\n        _classPrivateFieldGet(_addItemSize, this).call(this, index, size, status);\n        _classPrivateFieldGet(_valList, this)[index] = v;\n        if (status) {\n          status.set = 'replace';\n          const oldValue = oldVal && _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;\n          if (oldValue !== undefined) status.oldValue = oldValue;\n        }\n      } else if (status) {\n        status.set = 'update';\n      }\n    }\n    if (ttl !== 0 && !_classPrivateFieldGet(_ttls, this)) {\n      _assertClassBrand(_LRUCache_brand, this, _initializeTTLTracking).call(this);\n    }\n    if (_classPrivateFieldGet(_ttls, this)) {\n      if (!noUpdateTTL) {\n        _classPrivateFieldGet(_setItemTTL, this).call(this, index, ttl, start);\n      }\n      if (status) _classPrivateFieldGet(_statusTTL, this).call(this, status, index);\n    }\n    if (!noDisposeOnSet && _classPrivateFieldGet(_hasDisposeAfter, this) && _classPrivateFieldGet(_disposed, this)) {\n      const dt = _classPrivateFieldGet(_disposed, this);\n      let task;\n      while (task = dt === null || dt === void 0 ? void 0 : dt.shift()) {\n        var _classPrivateFieldGet6;\n        (_classPrivateFieldGet6 = _classPrivateFieldGet(_disposeAfter, this)) === null || _classPrivateFieldGet6 === void 0 || _classPrivateFieldGet6.call(this, ...task);\n      }\n    }\n    return this;\n  }\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop() {\n    try {\n      while (_classPrivateFieldGet(_size, this)) {\n        const val = _classPrivateFieldGet(_valList, this)[_classPrivateFieldGet(_head, this)];\n        _assertClassBrand(_LRUCache_brand, this, _evict).call(this, true);\n        if (_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching;\n          }\n        } else if (val !== undefined) {\n          return val;\n        }\n      }\n    } finally {\n      if (_classPrivateFieldGet(_hasDisposeAfter, this) && _classPrivateFieldGet(_disposed, this)) {\n        const dt = _classPrivateFieldGet(_disposed, this);\n        let task;\n        while (task = dt === null || dt === void 0 ? void 0 : dt.shift()) {\n          var _classPrivateFieldGet7;\n          (_classPrivateFieldGet7 = _classPrivateFieldGet(_disposeAfter, this)) === null || _classPrivateFieldGet7 === void 0 || _classPrivateFieldGet7.call(this, ...task);\n        }\n      }\n    }\n  }\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k) {\n    let hasOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      updateAgeOnHas = this.updateAgeOnHas,\n      status\n    } = hasOptions;\n    const index = _classPrivateFieldGet(_keyMap, this).get(k);\n    if (index !== undefined) {\n      const v = _classPrivateFieldGet(_valList, this)[index];\n      if (_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v) && v.__staleWhileFetching === undefined) {\n        return false;\n      }\n      if (!_classPrivateFieldGet(_isStale, this).call(this, index)) {\n        if (updateAgeOnHas) {\n          _classPrivateFieldGet(_updateItemAge, this).call(this, index);\n        }\n        if (status) {\n          status.has = 'hit';\n          _classPrivateFieldGet(_statusTTL, this).call(this, status, index);\n        }\n        return true;\n      } else if (status) {\n        status.has = 'stale';\n        _classPrivateFieldGet(_statusTTL, this).call(this, status, index);\n      }\n    } else if (status) {\n      status.has = 'miss';\n    }\n    return false;\n  }\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k) {\n    let peekOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      allowStale = this.allowStale\n    } = peekOptions;\n    const index = _classPrivateFieldGet(_keyMap, this).get(k);\n    if (index === undefined || !allowStale && _classPrivateFieldGet(_isStale, this).call(this, index)) {\n      return;\n    }\n    const v = _classPrivateFieldGet(_valList, this)[index];\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;\n  }\n  async fetch(k) {\n    let fetchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal\n    } = fetchOptions;\n    if (!_classPrivateFieldGet(_hasFetchMethod, this)) {\n      if (status) status.fetch = 'get';\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status\n      });\n    }\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal\n    };\n    let index = _classPrivateFieldGet(_keyMap, this).get(k);\n    if (index === undefined) {\n      if (status) status.fetch = 'miss';\n      const p = _assertClassBrand(_LRUCache_brand, this, _backgroundFetch).call(this, k, index, options, context);\n      return p.__returned = p;\n    } else {\n      // in cache, maybe already fetching\n      const v = _classPrivateFieldGet(_valList, this)[index];\n      if (_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v)) {\n        const stale = allowStale && v.__staleWhileFetching !== undefined;\n        if (status) {\n          status.fetch = 'inflight';\n          if (stale) status.returnedStale = true;\n        }\n        return stale ? v.__staleWhileFetching : v.__returned = v;\n      }\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = _classPrivateFieldGet(_isStale, this).call(this, index);\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit';\n        _assertClassBrand(_LRUCache_brand, this, _moveToTail).call(this, index);\n        if (updateAgeOnGet) {\n          _classPrivateFieldGet(_updateItemAge, this).call(this, index);\n        }\n        if (status) _classPrivateFieldGet(_statusTTL, this).call(this, status, index);\n        return v;\n      }\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = _assertClassBrand(_LRUCache_brand, this, _backgroundFetch).call(this, k, index, options, context);\n      const hasStale = p.__staleWhileFetching !== undefined;\n      const staleVal = hasStale && allowStale;\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh';\n        if (staleVal && isStale) status.returnedStale = true;\n      }\n      return staleVal ? p.__staleWhileFetching : p.__returned = p;\n    }\n  }\n  async forceFetch(k) {\n    let fetchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const v = await this.fetch(k, fetchOptions);\n    if (v === undefined) throw new Error('fetch() returned undefined');\n    return v;\n  }\n  memo(k) {\n    let memoOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const memoMethod = _classPrivateFieldGet(_memoMethod, this);\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor');\n    }\n    const {\n        context,\n        forceRefresh\n      } = memoOptions,\n      options = _objectWithoutProperties(memoOptions, _excluded);\n    const v = this.get(k, options);\n    if (!forceRefresh && v !== undefined) return v;\n    const vv = memoMethod(k, v, {\n      options,\n      context\n    });\n    this.set(k, vv, options);\n    return vv;\n  }\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k) {\n    let getOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status\n    } = getOptions;\n    const index = _classPrivateFieldGet(_keyMap, this).get(k);\n    if (index !== undefined) {\n      const value = _classPrivateFieldGet(_valList, this)[index];\n      const fetching = _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, value);\n      if (status) _classPrivateFieldGet(_statusTTL, this).call(this, status, index);\n      if (_classPrivateFieldGet(_isStale, this).call(this, index)) {\n        if (status) status.get = 'stale';\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            _assertClassBrand(_LRUCache_brand, this, _delete).call(this, k, 'expire');\n          }\n          if (status && allowStale) status.returnedStale = true;\n          return allowStale ? value : undefined;\n        } else {\n          if (status && allowStale && value.__staleWhileFetching !== undefined) {\n            status.returnedStale = true;\n          }\n          return allowStale ? value.__staleWhileFetching : undefined;\n        }\n      } else {\n        if (status) status.get = 'hit';\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching;\n        }\n        _assertClassBrand(_LRUCache_brand, this, _moveToTail).call(this, index);\n        if (updateAgeOnGet) {\n          _classPrivateFieldGet(_updateItemAge, this).call(this, index);\n        }\n        return value;\n      }\n    } else if (status) {\n      status.get = 'miss';\n    }\n  }\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k) {\n    return _assertClassBrand(_LRUCache_brand, this, _delete).call(this, k, 'delete');\n  }\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return _assertClassBrand(_LRUCache_brand, this, _clear).call(this, 'delete');\n  }\n}\n//# sourceMappingURL=index.js.map\nfunction _initializeTTLTracking() {\n  var _this = this;\n  const ttls = new ZeroArray(_classPrivateFieldGet(_max, this));\n  const starts = new ZeroArray(_classPrivateFieldGet(_max, this));\n  _classPrivateFieldSet(_ttls, this, ttls);\n  _classPrivateFieldSet(_starts, this, starts);\n  _classPrivateFieldSet(_setItemTTL, this, function (index, ttl) {\n    let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : perf.now();\n    starts[index] = ttl !== 0 ? start : 0;\n    ttls[index] = ttl;\n    if (ttl !== 0 && _this.ttlAutopurge) {\n      const t = setTimeout(() => {\n        if (_classPrivateFieldGet(_isStale, _this).call(_this, index)) {\n          _assertClassBrand(_LRUCache_brand, _this, _delete).call(_this, _classPrivateFieldGet(_keyList, _this)[index], 'expire');\n        }\n      }, ttl + 1);\n      // unref() not supported on all platforms\n      /* c8 ignore start */\n      if (t.unref) {\n        t.unref();\n      }\n      /* c8 ignore stop */\n    }\n  });\n  _classPrivateFieldSet(_updateItemAge, this, index => {\n    starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n  });\n  _classPrivateFieldSet(_statusTTL, this, (status, index) => {\n    if (ttls[index]) {\n      const ttl = ttls[index];\n      const start = starts[index];\n      /* c8 ignore next */\n      if (!ttl || !start) return;\n      status.ttl = ttl;\n      status.start = start;\n      status.now = cachedNow || getNow();\n      const age = status.now - start;\n      status.remainingTTL = ttl - age;\n    }\n  });\n  // debounce calls to perf.now() to 1s so we're not hitting\n  // that costly call repeatedly.\n  let cachedNow = 0;\n  const getNow = () => {\n    const n = perf.now();\n    if (this.ttlResolution > 0) {\n      cachedNow = n;\n      const t = setTimeout(() => cachedNow = 0, this.ttlResolution);\n      // not available on all platforms\n      /* c8 ignore start */\n      if (t.unref) {\n        t.unref();\n      }\n      /* c8 ignore stop */\n    }\n    return n;\n  };\n  this.getRemainingTTL = key => {\n    const index = _classPrivateFieldGet(_keyMap, this).get(key);\n    if (index === undefined) {\n      return 0;\n    }\n    const ttl = ttls[index];\n    const start = starts[index];\n    if (!ttl || !start) {\n      return Infinity;\n    }\n    const age = (cachedNow || getNow()) - start;\n    return ttl - age;\n  };\n  _classPrivateFieldSet(_isStale, this, index => {\n    const s = starts[index];\n    const t = ttls[index];\n    return !!t && !!s && (cachedNow || getNow()) - s > t;\n  });\n}\nfunction _initializeSizeTracking() {\n  const sizes = new ZeroArray(_classPrivateFieldGet(_max, this));\n  _classPrivateFieldSet(_calculatedSize, this, 0);\n  _classPrivateFieldSet(_sizes, this, sizes);\n  _classPrivateFieldSet(_removeItemSize, this, index => {\n    _classPrivateFieldSet(_calculatedSize, this, _classPrivateFieldGet(_calculatedSize, this) - sizes[index]);\n    sizes[index] = 0;\n  });\n  _classPrivateFieldSet(_requireSize, this, (k, v, size, sizeCalculation) => {\n    // provisionally accept background fetches.\n    // actual value size will be checked when they return.\n    if (_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v)) {\n      return 0;\n    }\n    if (!isPosInt(size)) {\n      if (sizeCalculation) {\n        if (typeof sizeCalculation !== 'function') {\n          throw new TypeError('sizeCalculation must be a function');\n        }\n        size = sizeCalculation(v, k);\n        if (!isPosInt(size)) {\n          throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n        }\n      } else {\n        throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation ' + 'or size must be set.');\n      }\n    }\n    return size;\n  });\n  _classPrivateFieldSet(_addItemSize, this, (index, size, status) => {\n    sizes[index] = size;\n    if (_classPrivateFieldGet(_maxSize, this)) {\n      const maxSize = _classPrivateFieldGet(_maxSize, this) - sizes[index];\n      while (_classPrivateFieldGet(_calculatedSize, this) > maxSize) {\n        _assertClassBrand(_LRUCache_brand, this, _evict).call(this, true);\n      }\n    }\n    _classPrivateFieldSet(_calculatedSize, this, _classPrivateFieldGet(_calculatedSize, this) + sizes[index]);\n    if (status) {\n      status.entrySize = size;\n      status.totalCalculatedSize = _classPrivateFieldGet(_calculatedSize, this);\n    }\n  });\n}\nfunction _indexes() {\n  var _this2 = this;\n  let {\n    allowStale = this.allowStale\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function* () {\n    if (_classPrivateFieldGet(_size, _this2)) {\n      for (let i = _classPrivateFieldGet(_tail, _this2); true;) {\n        if (!_assertClassBrand(_LRUCache_brand, _this2, _isValidIndex).call(_this2, i)) {\n          break;\n        }\n        if (allowStale || !_classPrivateFieldGet(_isStale, _this2).call(_this2, i)) {\n          yield i;\n        }\n        if (i === _classPrivateFieldGet(_head, _this2)) {\n          break;\n        } else {\n          i = _classPrivateFieldGet(_prev, _this2)[i];\n        }\n      }\n    }\n  }();\n}\nfunction _rindexes() {\n  var _this3 = this;\n  let {\n    allowStale = this.allowStale\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function* () {\n    if (_classPrivateFieldGet(_size, _this3)) {\n      for (let i = _classPrivateFieldGet(_head, _this3); true;) {\n        if (!_assertClassBrand(_LRUCache_brand, _this3, _isValidIndex).call(_this3, i)) {\n          break;\n        }\n        if (allowStale || !_classPrivateFieldGet(_isStale, _this3).call(_this3, i)) {\n          yield i;\n        }\n        if (i === _classPrivateFieldGet(_tail, _this3)) {\n          break;\n        } else {\n          i = _classPrivateFieldGet(_next, _this3)[i];\n        }\n      }\n    }\n  }();\n}\nfunction _isValidIndex(index) {\n  return index !== undefined && _classPrivateFieldGet(_keyMap, this).get(_classPrivateFieldGet(_keyList, this)[index]) === index;\n}\nfunction _evict(free) {\n  var _this$size3, _this$size4;\n  const head = _classPrivateFieldGet(_head, this);\n  const k = _classPrivateFieldGet(_keyList, this)[head];\n  const v = _classPrivateFieldGet(_valList, this)[head];\n  if (_classPrivateFieldGet(_hasFetchMethod, this) && _assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v)) {\n    v.__abortController.abort(new Error('evicted'));\n  } else if (_classPrivateFieldGet(_hasDispose, this) || _classPrivateFieldGet(_hasDisposeAfter, this)) {\n    if (_classPrivateFieldGet(_hasDispose, this)) {\n      var _classPrivateFieldGet8;\n      (_classPrivateFieldGet8 = _classPrivateFieldGet(_dispose, this)) === null || _classPrivateFieldGet8 === void 0 || _classPrivateFieldGet8.call(this, v, k, 'evict');\n    }\n    if (_classPrivateFieldGet(_hasDisposeAfter, this)) {\n      var _classPrivateFieldGet9;\n      (_classPrivateFieldGet9 = _classPrivateFieldGet(_disposed, this)) === null || _classPrivateFieldGet9 === void 0 || _classPrivateFieldGet9.push([v, k, 'evict']);\n    }\n  }\n  _classPrivateFieldGet(_removeItemSize, this).call(this, head);\n  // if we aren't about to use the index, then null these out\n  if (free) {\n    _classPrivateFieldGet(_keyList, this)[head] = undefined;\n    _classPrivateFieldGet(_valList, this)[head] = undefined;\n    _classPrivateFieldGet(_free, this).push(head);\n  }\n  if (_classPrivateFieldGet(_size, this) === 1) {\n    _classPrivateFieldSet(_head, this, _classPrivateFieldSet(_tail, this, 0));\n    _classPrivateFieldGet(_free, this).length = 0;\n  } else {\n    _classPrivateFieldSet(_head, this, _classPrivateFieldGet(_next, this)[head]);\n  }\n  _classPrivateFieldGet(_keyMap, this).delete(k);\n  _classPrivateFieldSet(_size, this, (_this$size3 = _classPrivateFieldGet(_size, this), _this$size4 = _this$size3--, _this$size3)), _this$size4;\n  return head;\n}\nfunction _backgroundFetch(k, index, options, context) {\n  var _this4 = this;\n  const v = index === undefined ? undefined : _classPrivateFieldGet(_valList, this)[index];\n  if (_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v)) {\n    return v;\n  }\n  const ac = new AC();\n  const {\n    signal\n  } = options;\n  // when/if our AC signals, then stop listening to theirs.\n  signal === null || signal === void 0 || signal.addEventListener('abort', () => ac.abort(signal.reason), {\n    signal: ac.signal\n  });\n  const fetchOpts = {\n    signal: ac.signal,\n    options,\n    context\n  };\n  const cb = function (v) {\n    let updateCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      aborted\n    } = ac.signal;\n    const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n    if (options.status) {\n      if (aborted && !updateCache) {\n        options.status.fetchAborted = true;\n        options.status.fetchError = ac.signal.reason;\n        if (ignoreAbort) options.status.fetchAbortIgnored = true;\n      } else {\n        options.status.fetchResolved = true;\n      }\n    }\n    if (aborted && !ignoreAbort && !updateCache) {\n      return fetchFail(ac.signal.reason);\n    }\n    // either we didn't abort, and are still here, or we did, and ignored\n    const bf = p;\n    if (_classPrivateFieldGet(_valList, _this4)[index] === p) {\n      if (v === undefined) {\n        if (bf.__staleWhileFetching) {\n          _classPrivateFieldGet(_valList, _this4)[index] = bf.__staleWhileFetching;\n        } else {\n          _assertClassBrand(_LRUCache_brand, _this4, _delete).call(_this4, k, 'fetch');\n        }\n      } else {\n        if (options.status) options.status.fetchUpdated = true;\n        _this4.set(k, v, fetchOpts.options);\n      }\n    }\n    return v;\n  };\n  const eb = er => {\n    if (options.status) {\n      options.status.fetchRejected = true;\n      options.status.fetchError = er;\n    }\n    return fetchFail(er);\n  };\n  const fetchFail = er => {\n    const {\n      aborted\n    } = ac.signal;\n    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n    const noDelete = allowStale || options.noDeleteOnFetchRejection;\n    const bf = p;\n    if (_classPrivateFieldGet(_valList, this)[index] === p) {\n      // if we allow stale on fetch rejections, then we need to ensure that\n      // the stale value is not removed from the cache when the fetch fails.\n      const del = !noDelete || bf.__staleWhileFetching === undefined;\n      if (del) {\n        _assertClassBrand(_LRUCache_brand, this, _delete).call(this, k, 'fetch');\n      } else if (!allowStaleAborted) {\n        // still replace the *promise* with the stale value,\n        // since we are done with the promise at this point.\n        // leave it untouched if we're still waiting for an\n        // aborted background fetch that hasn't yet returned.\n        _classPrivateFieldGet(_valList, this)[index] = bf.__staleWhileFetching;\n      }\n    }\n    if (allowStale) {\n      if (options.status && bf.__staleWhileFetching !== undefined) {\n        options.status.returnedStale = true;\n      }\n      return bf.__staleWhileFetching;\n    } else if (bf.__returned === bf) {\n      throw er;\n    }\n  };\n  const pcall = (res, rej) => {\n    var _classPrivateFieldGet0;\n    const fmp = (_classPrivateFieldGet0 = _classPrivateFieldGet(_fetchMethod, this)) === null || _classPrivateFieldGet0 === void 0 ? void 0 : _classPrivateFieldGet0.call(this, k, v, fetchOpts);\n    if (fmp && fmp instanceof Promise) {\n      fmp.then(v => res(v === undefined ? undefined : v), rej);\n    }\n    // ignored, we go until we finish, regardless.\n    // defer check until we are actually aborting,\n    // so fetchMethod can override.\n    ac.signal.addEventListener('abort', () => {\n      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n        res(undefined);\n        // when it eventually resolves, update the cache.\n        if (options.allowStaleOnFetchAbort) {\n          res = v => cb(v, true);\n        }\n      }\n    });\n  };\n  if (options.status) options.status.fetchDispatched = true;\n  const p = new Promise(pcall).then(cb, eb);\n  const bf = Object.assign(p, {\n    __abortController: ac,\n    __staleWhileFetching: v,\n    __returned: undefined\n  });\n  if (index === undefined) {\n    // internal, don't expose status.\n    this.set(k, bf, _objectSpread(_objectSpread({}, fetchOpts.options), {}, {\n      status: undefined\n    }));\n    index = _classPrivateFieldGet(_keyMap, this).get(k);\n  } else {\n    _classPrivateFieldGet(_valList, this)[index] = bf;\n  }\n  return bf;\n}\nfunction _isBackgroundFetch(p) {\n  if (!_classPrivateFieldGet(_hasFetchMethod, this)) return false;\n  const b = p;\n  return !!b && b instanceof Promise && b.hasOwnProperty('__staleWhileFetching') && b.__abortController instanceof AC;\n}\nfunction _connect(p, n) {\n  _classPrivateFieldGet(_prev, this)[n] = p;\n  _classPrivateFieldGet(_next, this)[p] = n;\n}\nfunction _moveToTail(index) {\n  // if tail already, nothing to do\n  // if head, move head to next[index]\n  // else\n  //   move next[prev[index]] to next[index] (head has no prev)\n  //   move prev[next[index]] to prev[index]\n  // prev[index] = tail\n  // next[tail] = index\n  // tail = index\n  if (index !== _classPrivateFieldGet(_tail, this)) {\n    if (index === _classPrivateFieldGet(_head, this)) {\n      _classPrivateFieldSet(_head, this, _classPrivateFieldGet(_next, this)[index]);\n    } else {\n      _assertClassBrand(_LRUCache_brand, this, _connect).call(this, _classPrivateFieldGet(_prev, this)[index], _classPrivateFieldGet(_next, this)[index]);\n    }\n    _assertClassBrand(_LRUCache_brand, this, _connect).call(this, _classPrivateFieldGet(_tail, this), index);\n    _classPrivateFieldSet(_tail, this, index);\n  }\n}\nfunction _delete(k, reason) {\n  var _classPrivateFieldGet11;\n  let deleted = false;\n  if (_classPrivateFieldGet(_size, this) !== 0) {\n    const index = _classPrivateFieldGet(_keyMap, this).get(k);\n    if (index !== undefined) {\n      deleted = true;\n      if (_classPrivateFieldGet(_size, this) === 1) {\n        _assertClassBrand(_LRUCache_brand, this, _clear).call(this, reason);\n      } else {\n        var _this$size5, _this$size6;\n        _classPrivateFieldGet(_removeItemSize, this).call(this, index);\n        const v = _classPrivateFieldGet(_valList, this)[index];\n        if (_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v)) {\n          v.__abortController.abort(new Error('deleted'));\n        } else if (_classPrivateFieldGet(_hasDispose, this) || _classPrivateFieldGet(_hasDisposeAfter, this)) {\n          if (_classPrivateFieldGet(_hasDispose, this)) {\n            var _classPrivateFieldGet1;\n            (_classPrivateFieldGet1 = _classPrivateFieldGet(_dispose, this)) === null || _classPrivateFieldGet1 === void 0 || _classPrivateFieldGet1.call(this, v, k, reason);\n          }\n          if (_classPrivateFieldGet(_hasDisposeAfter, this)) {\n            var _classPrivateFieldGet10;\n            (_classPrivateFieldGet10 = _classPrivateFieldGet(_disposed, this)) === null || _classPrivateFieldGet10 === void 0 || _classPrivateFieldGet10.push([v, k, reason]);\n          }\n        }\n        _classPrivateFieldGet(_keyMap, this).delete(k);\n        _classPrivateFieldGet(_keyList, this)[index] = undefined;\n        _classPrivateFieldGet(_valList, this)[index] = undefined;\n        if (index === _classPrivateFieldGet(_tail, this)) {\n          _classPrivateFieldSet(_tail, this, _classPrivateFieldGet(_prev, this)[index]);\n        } else if (index === _classPrivateFieldGet(_head, this)) {\n          _classPrivateFieldSet(_head, this, _classPrivateFieldGet(_next, this)[index]);\n        } else {\n          const pi = _classPrivateFieldGet(_prev, this)[index];\n          _classPrivateFieldGet(_next, this)[pi] = _classPrivateFieldGet(_next, this)[index];\n          const ni = _classPrivateFieldGet(_next, this)[index];\n          _classPrivateFieldGet(_prev, this)[ni] = _classPrivateFieldGet(_prev, this)[index];\n        }\n        _classPrivateFieldSet(_size, this, (_this$size5 = _classPrivateFieldGet(_size, this), _this$size6 = _this$size5--, _this$size5)), _this$size6;\n        _classPrivateFieldGet(_free, this).push(index);\n      }\n    }\n  }\n  if (_classPrivateFieldGet(_hasDisposeAfter, this) && (_classPrivateFieldGet11 = _classPrivateFieldGet(_disposed, this)) !== null && _classPrivateFieldGet11 !== void 0 && _classPrivateFieldGet11.length) {\n    const dt = _classPrivateFieldGet(_disposed, this);\n    let task;\n    while (task = dt === null || dt === void 0 ? void 0 : dt.shift()) {\n      var _classPrivateFieldGet12;\n      (_classPrivateFieldGet12 = _classPrivateFieldGet(_disposeAfter, this)) === null || _classPrivateFieldGet12 === void 0 || _classPrivateFieldGet12.call(this, ...task);\n    }\n  }\n  return deleted;\n}\nfunction _clear(reason) {\n  for (const index of _assertClassBrand(_LRUCache_brand, this, _rindexes).call(this, {\n    allowStale: true\n  })) {\n    const v = _classPrivateFieldGet(_valList, this)[index];\n    if (_assertClassBrand(_LRUCache_brand, this, _isBackgroundFetch).call(this, v)) {\n      v.__abortController.abort(new Error('deleted'));\n    } else {\n      const k = _classPrivateFieldGet(_keyList, this)[index];\n      if (_classPrivateFieldGet(_hasDispose, this)) {\n        var _classPrivateFieldGet13;\n        (_classPrivateFieldGet13 = _classPrivateFieldGet(_dispose, this)) === null || _classPrivateFieldGet13 === void 0 || _classPrivateFieldGet13.call(this, v, k, reason);\n      }\n      if (_classPrivateFieldGet(_hasDisposeAfter, this)) {\n        var _classPrivateFieldGet14;\n        (_classPrivateFieldGet14 = _classPrivateFieldGet(_disposed, this)) === null || _classPrivateFieldGet14 === void 0 || _classPrivateFieldGet14.push([v, k, reason]);\n      }\n    }\n  }\n  _classPrivateFieldGet(_keyMap, this).clear();\n  _classPrivateFieldGet(_valList, this).fill(undefined);\n  _classPrivateFieldGet(_keyList, this).fill(undefined);\n  if (_classPrivateFieldGet(_ttls, this) && _classPrivateFieldGet(_starts, this)) {\n    _classPrivateFieldGet(_ttls, this).fill(0);\n    _classPrivateFieldGet(_starts, this).fill(0);\n  }\n  if (_classPrivateFieldGet(_sizes, this)) {\n    _classPrivateFieldGet(_sizes, this).fill(0);\n  }\n  _classPrivateFieldSet(_head, this, 0);\n  _classPrivateFieldSet(_tail, this, 0);\n  _classPrivateFieldGet(_free, this).length = 0;\n  _classPrivateFieldSet(_calculatedSize, this, 0);\n  _classPrivateFieldSet(_size, this, 0);\n  if (_classPrivateFieldGet(_hasDisposeAfter, this) && _classPrivateFieldGet(_disposed, this)) {\n    const dt = _classPrivateFieldGet(_disposed, this);\n    let task;\n    while (task = dt === null || dt === void 0 ? void 0 : dt.shift()) {\n      var _classPrivateFieldGet15;\n      (_classPrivateFieldGet15 = _classPrivateFieldGet(_disposeAfter, this)) === null || _classPrivateFieldGet15 === void 0 || _classPrivateFieldGet15.call(this, ...task);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}