{"ast":null,"code":"import { toBase64 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { normalizeSuiObjectId } from \"../utils/sui-types.js\";\nimport { ArgumentSchema } from \"./data/internal.js\";\nvar UpgradePolicy = /* @__PURE__ */(UpgradePolicy2 => {\n  UpgradePolicy2[UpgradePolicy2[\"COMPATIBLE\"] = 0] = \"COMPATIBLE\";\n  UpgradePolicy2[UpgradePolicy2[\"ADDITIVE\"] = 128] = \"ADDITIVE\";\n  UpgradePolicy2[UpgradePolicy2[\"DEP_ONLY\"] = 192] = \"DEP_ONLY\";\n  return UpgradePolicy2;\n})(UpgradePolicy || {});\nconst Commands = {\n  MoveCall(input) {\n    var _input$typeArguments, _input$arguments;\n    const [pkg, mod = \"\", fn = \"\"] = \"target\" in input ? input.target.split(\"::\") : [input.package, input.module, input.function];\n    return {\n      $kind: \"MoveCall\",\n      MoveCall: {\n        package: pkg,\n        module: mod,\n        function: fn,\n        typeArguments: (_input$typeArguments = input.typeArguments) !== null && _input$typeArguments !== void 0 ? _input$typeArguments : [],\n        arguments: (_input$arguments = input.arguments) !== null && _input$arguments !== void 0 ? _input$arguments : []\n      }\n    };\n  },\n  TransferObjects(objects, address) {\n    return {\n      $kind: \"TransferObjects\",\n      TransferObjects: {\n        objects: objects.map(o => parse(ArgumentSchema, o)),\n        address: parse(ArgumentSchema, address)\n      }\n    };\n  },\n  SplitCoins(coin, amounts) {\n    return {\n      $kind: \"SplitCoins\",\n      SplitCoins: {\n        coin: parse(ArgumentSchema, coin),\n        amounts: amounts.map(o => parse(ArgumentSchema, o))\n      }\n    };\n  },\n  MergeCoins(destination, sources) {\n    return {\n      $kind: \"MergeCoins\",\n      MergeCoins: {\n        destination: parse(ArgumentSchema, destination),\n        sources: sources.map(o => parse(ArgumentSchema, o))\n      }\n    };\n  },\n  Publish(_ref) {\n    let {\n      modules,\n      dependencies\n    } = _ref;\n    return {\n      $kind: \"Publish\",\n      Publish: {\n        modules: modules.map(module => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))),\n        dependencies: dependencies.map(dep => normalizeSuiObjectId(dep))\n      }\n    };\n  },\n  Upgrade(_ref2) {\n    let {\n      modules,\n      dependencies,\n      package: packageId,\n      ticket\n    } = _ref2;\n    return {\n      $kind: \"Upgrade\",\n      Upgrade: {\n        modules: modules.map(module => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))),\n        dependencies: dependencies.map(dep => normalizeSuiObjectId(dep)),\n        package: packageId,\n        ticket: parse(ArgumentSchema, ticket)\n      }\n    };\n  },\n  MakeMoveVec(_ref3) {\n    let {\n      type,\n      elements\n    } = _ref3;\n    return {\n      $kind: \"MakeMoveVec\",\n      MakeMoveVec: {\n        type: type !== null && type !== void 0 ? type : null,\n        elements: elements.map(o => parse(ArgumentSchema, o))\n      }\n    };\n  },\n  Intent(_ref4) {\n    let {\n      name,\n      inputs = {},\n      data = {}\n    } = _ref4;\n    return {\n      $kind: \"$Intent\",\n      $Intent: {\n        name,\n        inputs: Object.fromEntries(Object.entries(inputs).map(_ref5 => {\n          let [key, value] = _ref5;\n          return [key, Array.isArray(value) ? value.map(o => parse(ArgumentSchema, o)) : parse(ArgumentSchema, value)];\n        })),\n        data\n      }\n    };\n  }\n};\nexport { Commands, UpgradePolicy };\n//# sourceMappingURL=Commands.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}