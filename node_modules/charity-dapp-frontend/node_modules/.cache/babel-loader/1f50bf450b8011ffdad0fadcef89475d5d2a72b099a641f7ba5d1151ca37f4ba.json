{"ast":null,"code":"import _objectSpread from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { TransactionDataBuilder } from \"../../transactions/TransactionData.js\";\nfunction parseTransactionBcs(bytes) {\n  return _objectSpread(_objectSpread({}, TransactionDataBuilder.fromBytes(bytes).snapshot()), {}, {\n    bcs: bytes\n  });\n}\nfunction parseTransactionEffectsBcs(effects) {\n  const parsed = bcs.TransactionEffects.parse(effects);\n  switch (parsed.$kind) {\n    case \"V1\":\n      return parseTransactionEffectsV1({\n        bytes: effects,\n        effects: parsed.V1\n      });\n    case \"V2\":\n      return parseTransactionEffectsV2({\n        bytes: effects,\n        effects: parsed.V2\n      });\n    default:\n      throw new Error(\"Unknown transaction effects version: \".concat(parsed.$kind));\n  }\n}\nfunction parseTransactionEffectsV1(_) {\n  throw new Error(\"V1 effects are not supported yet\");\n}\nfunction parseTransactionEffectsV2(_ref) {\n  var _changedObjects$effec;\n  let {\n    bytes,\n    effects\n  } = _ref;\n  const changedObjects = effects.changedObjects.map(_ref2 => {\n    var _change$inputState$Ex, _change$inputState$Ex2, _change$inputState$Ex3, _change$inputState$Ex4, _change$inputState$Ex5, _change$inputState$Ex6, _change$outputState$P, _change$outputState$P2, _change$outputState$O, _change$outputState$O2;\n    let [id, change] = _ref2;\n    return {\n      id,\n      inputState: change.inputState.$kind === \"Exist\" ? \"Exists\" : \"DoesNotExist\",\n      inputVersion: (_change$inputState$Ex = (_change$inputState$Ex2 = change.inputState.Exist) === null || _change$inputState$Ex2 === void 0 ? void 0 : _change$inputState$Ex2[0][0]) !== null && _change$inputState$Ex !== void 0 ? _change$inputState$Ex : null,\n      inputDigest: (_change$inputState$Ex3 = (_change$inputState$Ex4 = change.inputState.Exist) === null || _change$inputState$Ex4 === void 0 ? void 0 : _change$inputState$Ex4[0][1]) !== null && _change$inputState$Ex3 !== void 0 ? _change$inputState$Ex3 : null,\n      inputOwner: (_change$inputState$Ex5 = (_change$inputState$Ex6 = change.inputState.Exist) === null || _change$inputState$Ex6 === void 0 ? void 0 : _change$inputState$Ex6[1]) !== null && _change$inputState$Ex5 !== void 0 ? _change$inputState$Ex5 : null,\n      outputState: change.outputState.$kind === \"NotExist\" ? \"DoesNotExist\" : change.outputState.$kind,\n      outputVersion: change.outputState.$kind === \"PackageWrite\" ? (_change$outputState$P = change.outputState.PackageWrite) === null || _change$outputState$P === void 0 ? void 0 : _change$outputState$P[0] : change.outputState.ObjectWrite ? effects.lamportVersion : null,\n      outputDigest: change.outputState.$kind === \"PackageWrite\" ? (_change$outputState$P2 = change.outputState.PackageWrite) === null || _change$outputState$P2 === void 0 ? void 0 : _change$outputState$P2[1] : (_change$outputState$O = (_change$outputState$O2 = change.outputState.ObjectWrite) === null || _change$outputState$O2 === void 0 ? void 0 : _change$outputState$O2[0]) !== null && _change$outputState$O !== void 0 ? _change$outputState$O : null,\n      outputOwner: change.outputState.ObjectWrite ? change.outputState.ObjectWrite[1] : null,\n      idOperation: change.idOperation.$kind\n    };\n  });\n  return {\n    bcs: bytes,\n    digest: effects.transactionDigest,\n    version: 2,\n    status: effects.status.$kind === \"Success\" ? {\n      success: true,\n      error: null\n    } : {\n      success: false,\n      // TODO: add command\n      error: effects.status.Failed.error.$kind\n    },\n    gasUsed: effects.gasUsed,\n    transactionDigest: effects.transactionDigest,\n    gasObject: effects.gasObjectIndex === null ? null : (_changedObjects$effec = changedObjects[effects.gasObjectIndex]) !== null && _changedObjects$effec !== void 0 ? _changedObjects$effec : null,\n    eventsDigest: effects.eventsDigest,\n    dependencies: effects.dependencies,\n    lamportVersion: effects.lamportVersion,\n    changedObjects,\n    unchangedConsensusObjects: effects.unchangedSharedObjects.map(_ref3 => {\n      let [objectId, object] = _ref3;\n      return {\n        kind: object.$kind === \"MutateDeleted\" ? \"MutateConsensusStreamEnded\" : object.$kind === \"ReadDeleted\" ? \"ReadConsensusStreamEnded\" : object.$kind,\n        objectId,\n        version: object.$kind === \"ReadOnlyRoot\" ? object.ReadOnlyRoot[0] : object[object.$kind],\n        digest: object.$kind === \"ReadOnlyRoot\" ? object.ReadOnlyRoot[1] : null\n      };\n    }),\n    auxiliaryDataDigest: effects.auxDataDigest\n  };\n}\nexport { parseTransactionBcs, parseTransactionEffectsBcs };\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}