{"ast":null,"code":"import _asyncIterator from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n// src/streamedQuery.ts\nimport { addToEnd } from \"./utils.js\";\nfunction streamedQuery(_ref) {\n  let {\n    streamFn,\n    refetchMode = \"reset\",\n    reducer = (items, chunk) => addToEnd(items, chunk),\n    initialValue = []\n  } = _ref;\n  return async context => {\n    var _context$client$getQu;\n    const query = context.client.getQueryCache().find({\n      queryKey: context.queryKey,\n      exact: true\n    });\n    const isRefetch = !!query && query.state.data !== void 0;\n    if (isRefetch && refetchMode === \"reset\") {\n      query.setState({\n        status: \"pending\",\n        data: void 0,\n        error: null,\n        fetchStatus: \"fetching\"\n      });\n    }\n    let result = initialValue;\n    const stream = await streamFn(context);\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const chunk = _step.value;\n        {\n          if (context.signal.aborted) {\n            break;\n          }\n          if (!isRefetch || refetchMode !== \"replace\") {\n            context.client.setQueryData(context.queryKey, prev => reducer(prev === void 0 ? initialValue : prev, chunk));\n          }\n          result = reducer(result, chunk);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if (isRefetch && refetchMode === \"replace\" && !context.signal.aborted) {\n      context.client.setQueryData(context.queryKey, result);\n    }\n    return (_context$client$getQu = context.client.getQueryData(context.queryKey)) !== null && _context$client$getQu !== void 0 ? _context$client$getQu : initialValue;\n  };\n}\nexport { streamedQuery };\n//# sourceMappingURL=streamedQuery.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}