{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/DMC/OneDrive/Documents/SUIMOVE/charity-dapp/charity-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"size\"],\n  _excluded2 = [\"readMethod\", \"writeMethod\"],\n  _excluded3 = [\"readMethod\", \"writeMethod\"],\n  _excluded4 = [\"serialize\"],\n  _excluded5 = [\"toBytes\", \"fromBytes\"],\n  _excluded6 = [\"name\", \"fields\"],\n  _excluded7 = [\"fields\"],\n  _excluded8 = [\"fields\", \"name\"];\nvar __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _write, _serialize, _schema, _bytes;\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from \"@mysten/utils\";\nimport { BcsReader } from \"./reader.js\";\nimport { ulebEncode } from \"./uleb.js\";\nimport { BcsWriter } from \"./writer.js\";\nconst _BcsType = class _BcsType {\n  constructor(options) {\n    var _options$serializedSi, _options$serialize, _options$validate;\n    __privateAdd(this, _write);\n    __privateAdd(this, _serialize);\n    this.name = options.name;\n    this.read = options.read;\n    this.serializedSize = (_options$serializedSi = options.serializedSize) !== null && _options$serializedSi !== void 0 ? _options$serializedSi : () => null;\n    __privateSet(this, _write, options.write);\n    __privateSet(this, _serialize, (_options$serialize = options.serialize) !== null && _options$serialize !== void 0 ? _options$serialize : (value, options2) => {\n      var _this$serializedSize;\n      const writer = new BcsWriter(_objectSpread({\n        initialSize: (_this$serializedSize = this.serializedSize(value)) !== null && _this$serializedSize !== void 0 ? _this$serializedSize : void 0\n      }, options2));\n      __privateGet(this, _write).call(this, value, writer);\n      return writer.toBytes();\n    });\n    this.validate = (_options$validate = options.validate) !== null && _options$validate !== void 0 ? _options$validate : () => {};\n  }\n  write(value, writer) {\n    this.validate(value);\n    __privateGet(this, _write).call(this, value, writer);\n  }\n  serialize(value, options) {\n    this.validate(value);\n    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n  }\n  parse(bytes) {\n    const reader = new BcsReader(bytes);\n    return this.read(reader);\n  }\n  fromHex(hex) {\n    return this.parse(fromHex(hex));\n  }\n  fromBase58(b64) {\n    return this.parse(fromBase58(b64));\n  }\n  fromBase64(b64) {\n    return this.parse(fromBase64(b64));\n  }\n  transform(_ref) {\n    let {\n      name,\n      input,\n      output,\n      validate\n    } = _ref;\n    return new _BcsType({\n      name: name !== null && name !== void 0 ? name : this.name,\n      read: reader => output ? output(this.read(reader)) : this.read(reader),\n      write: (value, writer) => __privateGet(this, _write).call(this, input ? input(value) : value, writer),\n      serializedSize: value => this.serializedSize(input ? input(value) : value),\n      serialize: (value, options) => __privateGet(this, _serialize).call(this, input ? input(value) : value, options),\n      validate: value => {\n        validate === null || validate === void 0 || validate(value);\n        this.validate(input ? input(value) : value);\n      }\n    });\n  }\n};\n_write = new WeakMap();\n_serialize = new WeakMap();\nlet BcsType = _BcsType;\nconst SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n  return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nclass SerializedBcs {\n  constructor(schema, bytes) {\n    __privateAdd(this, _schema);\n    __privateAdd(this, _bytes);\n    __privateSet(this, _schema, schema);\n    __privateSet(this, _bytes, bytes);\n  }\n  // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n  // of the @mysten/bcs package are installed\n  get [SERIALIZED_BCS_BRAND]() {\n    return true;\n  }\n  toBytes() {\n    return __privateGet(this, _bytes);\n  }\n  toHex() {\n    return toHex(__privateGet(this, _bytes));\n  }\n  toBase64() {\n    return toBase64(__privateGet(this, _bytes));\n  }\n  toBase58() {\n    return toBase58(__privateGet(this, _bytes));\n  }\n  parse() {\n    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n  }\n}\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType(_ref2) {\n  let {\n      size\n    } = _ref2,\n    options = _objectWithoutProperties(_ref2, _excluded);\n  return new BcsType(_objectSpread(_objectSpread({}, options), {}, {\n    serializedSize: () => size\n  }));\n}\nfunction uIntBcsType(_ref3) {\n  let {\n      readMethod,\n      writeMethod\n    } = _ref3,\n    options = _objectWithoutProperties(_ref3, _excluded2);\n  return fixedSizeBcsType(_objectSpread(_objectSpread({}, options), {}, {\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](value),\n    validate: value => {\n      var _options$validate2;\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\"Invalid \".concat(options.name, \" value: \").concat(value, \". Expected value in range 0-\").concat(options.maxValue));\n      }\n      (_options$validate2 = options.validate) === null || _options$validate2 === void 0 || _options$validate2.call(options, value);\n    }\n  }));\n}\nfunction bigUIntBcsType(_ref4) {\n  let {\n      readMethod,\n      writeMethod\n    } = _ref4,\n    options = _objectWithoutProperties(_ref4, _excluded3);\n  return fixedSizeBcsType(_objectSpread(_objectSpread({}, options), {}, {\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](BigInt(value)),\n    validate: val => {\n      var _options$validate3;\n      const value = BigInt(val);\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\"Invalid \".concat(options.name, \" value: \").concat(value, \". Expected value in range 0-\").concat(options.maxValue));\n      }\n      (_options$validate3 = options.validate) === null || _options$validate3 === void 0 || _options$validate3.call(options, value);\n    }\n  }));\n}\nfunction dynamicSizeBcsType(_ref5) {\n  let {\n      serialize\n    } = _ref5,\n    options = _objectWithoutProperties(_ref5, _excluded4);\n  const type = new BcsType(_objectSpread(_objectSpread({}, options), {}, {\n    serialize,\n    write: (value, writer) => {\n      for (const byte of type.serialize(value).toBytes()) {\n        writer.write8(byte);\n      }\n    }\n  }));\n  return type;\n}\nfunction stringLikeBcsType(_ref6) {\n  let {\n      toBytes,\n      fromBytes\n    } = _ref6,\n    options = _objectWithoutProperties(_ref6, _excluded5);\n  return new BcsType(_objectSpread(_objectSpread({}, options), {}, {\n    read: reader => {\n      const length = reader.readULEB();\n      const bytes = reader.readBytes(length);\n      return fromBytes(bytes);\n    },\n    write: (hex, writer) => {\n      const bytes = toBytes(hex);\n      writer.writeULEB(bytes.length);\n      for (let i = 0; i < bytes.length; i++) {\n        writer.write8(bytes[i]);\n      }\n    },\n    serialize: value => {\n      const bytes = toBytes(value);\n      const size = ulebEncode(bytes.length);\n      const result = new Uint8Array(size.length + bytes.length);\n      result.set(size, 0);\n      result.set(bytes, size.length);\n      return result;\n    },\n    validate: value => {\n      var _options$validate4;\n      if (typeof value !== \"string\") {\n        throw new TypeError(\"Invalid \".concat(options.name, \" value: \").concat(value, \". Expected string\"));\n      }\n      (_options$validate4 = options.validate) === null || _options$validate4 === void 0 || _options$validate4.call(options, value);\n    }\n  }));\n}\nfunction lazyBcsType(cb) {\n  let lazyType = null;\n  function getType() {\n    if (!lazyType) {\n      lazyType = cb();\n    }\n    return lazyType;\n  }\n  return new BcsType({\n    name: \"lazy\",\n    read: data => getType().read(data),\n    serializedSize: value => getType().serializedSize(value),\n    write: (value, writer) => getType().write(value, writer),\n    serialize: (value, options) => getType().serialize(value, options).toBytes()\n  });\n}\nclass BcsStruct extends BcsType {\n  constructor(_ref7) {\n    let {\n        name,\n        fields\n      } = _ref7,\n      options = _objectWithoutProperties(_ref7, _excluded6);\n    const canonicalOrder = Object.entries(fields);\n    super(_objectSpread(_objectSpread({\n      name,\n      serializedSize: values => {\n        let total = 0;\n        for (const [field, type] of canonicalOrder) {\n          const size = type.serializedSize(values[field]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = {};\n        for (const [field, type] of canonicalOrder) {\n          result[field] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const [field, type] of canonicalOrder) {\n          type.write(value[field], writer);\n        }\n      }\n    }, options), {}, {\n      validate: value => {\n        var _options$validate5;\n        options === null || options === void 0 || (_options$validate5 = options.validate) === null || _options$validate5 === void 0 || _options$validate5.call(options, value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(\"Expected object, found \".concat(typeof value));\n        }\n      }\n    }));\n  }\n}\nclass BcsEnum extends BcsType {\n  constructor(_ref8) {\n    let {\n        fields\n      } = _ref8,\n      options = _objectWithoutProperties(_ref8, _excluded7);\n    const canonicalOrder = Object.entries(fields);\n    super(_objectSpread(_objectSpread({\n      read: reader => {\n        var _type$read;\n        const index = reader.readULEB();\n        const enumEntry = canonicalOrder[index];\n        if (!enumEntry) {\n          throw new TypeError(\"Unknown value \".concat(index, \" for enum \").concat(options.name));\n        }\n        const [kind, type] = enumEntry;\n        return {\n          [kind]: (_type$read = type === null || type === void 0 ? void 0 : type.read(reader)) !== null && _type$read !== void 0 ? _type$read : true,\n          $kind: kind\n        };\n      },\n      write: (value, writer) => {\n        const [name, val] = Object.entries(value).filter(_ref9 => {\n          let [name2] = _ref9;\n          return Object.hasOwn(fields, name2);\n        })[0];\n        for (let i = 0; i < canonicalOrder.length; i++) {\n          const [optionName, optionType] = canonicalOrder[i];\n          if (optionName === name) {\n            writer.writeULEB(i);\n            optionType === null || optionType === void 0 || optionType.write(val, writer);\n            return;\n          }\n        }\n      }\n    }, options), {}, {\n      validate: value => {\n        var _options$validate6;\n        options === null || options === void 0 || (_options$validate6 = options.validate) === null || _options$validate6 === void 0 || _options$validate6.call(options, value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(\"Expected object, found \".concat(typeof value));\n        }\n        const keys = Object.keys(value).filter(k => value[k] !== void 0 && Object.hasOwn(fields, k));\n        if (keys.length !== 1) {\n          throw new TypeError(\"Expected object with one key, but found \".concat(keys.length, \" for type \").concat(options.name, \"}\"));\n        }\n        const [variant] = keys;\n        if (!Object.hasOwn(fields, variant)) {\n          throw new TypeError(\"Invalid enum variant \".concat(variant));\n        }\n      }\n    }));\n  }\n}\nclass BcsTuple extends BcsType {\n  constructor(_ref0) {\n    let {\n        fields,\n        name\n      } = _ref0,\n      options = _objectWithoutProperties(_ref0, _excluded8);\n    super(_objectSpread(_objectSpread({\n      name: name !== null && name !== void 0 ? name : \"(\".concat(fields.map(t => t.name).join(\", \"), \")\"),\n      serializedSize: values => {\n        let total = 0;\n        for (let i = 0; i < fields.length; i++) {\n          const size = fields[i].serializedSize(values[i]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = [];\n        for (const field of fields) {\n          result.push(field.read(reader));\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (let i = 0; i < fields.length; i++) {\n          fields[i].write(value[i], writer);\n        }\n      }\n    }, options), {}, {\n      validate: value => {\n        var _options$validate7;\n        options === null || options === void 0 || (_options$validate7 = options.validate) === null || _options$validate7 === void 0 || _options$validate7.call(options, value);\n        if (!Array.isArray(value)) {\n          throw new TypeError(\"Expected array, found \".concat(typeof value));\n        }\n        if (value.length !== fields.length) {\n          throw new TypeError(\"Expected array of length \".concat(fields.length, \", found \").concat(value.length));\n        }\n      }\n    }));\n  }\n}\nexport { BcsEnum, BcsStruct, BcsTuple, BcsType, SerializedBcs, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, isSerializedBcs, lazyBcsType, stringLikeBcsType, uIntBcsType };\n//# sourceMappingURL=bcs-type.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}